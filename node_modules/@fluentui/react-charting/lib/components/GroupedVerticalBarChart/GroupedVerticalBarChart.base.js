import { __assign, __extends } from "tslib";
import * as React from 'react';
import { max as d3Max } from 'd3-array';
import { select as d3Select } from 'd3-selection';
import { scaleBand as d3ScaleBand, scaleLinear as d3ScaleLinear } from 'd3-scale';
import { classNamesFunction, getId, getRTL, memoizeFunction, warnDeprecations } from '@fluentui/react/lib/Utilities';
import { DirectionalHint } from '@fluentui/react/lib/Callout';
import { FocusZoneDirection } from '@fluentui/react-focus';
import { ChartTypes, getAccessibleDataObject, tooltipOfXAxislabels, getTypeOfAxis, } from '../../utilities/index';
import { CartesianChart, Legends, } from '../../index';
var COMPONENT_NAME = 'GROUPED VERTICAL BAR CHART';
var BAR_SPACE = 2.5;
var getClassNames = classNamesFunction();
var GroupedVerticalBarChartBase = /** @class */ (function (_super) {
    __extends(GroupedVerticalBarChartBase, _super);
    function GroupedVerticalBarChartBase(props) {
        var _this = _super.call(this, props) || this;
        _this._isRtl = getRTL();
        _this._getGraphData = function (xScale, yScale, containerHeight, containerWidth, xElement) {
            var xScale0 = _this._createX0Scale(containerWidth);
            var xScale1 = _this._createX1Scale(xScale0);
            var allGroupsBars = [];
            _this._datasetForBars.forEach(function (singleSet) {
                allGroupsBars.push(_this._buildGraph(singleSet, xScale0, xScale1, containerHeight, xElement));
            });
            _this._groupedVerticalBarGraph = allGroupsBars;
        };
        _this._getMargins = function (margins) { return (_this.margins = margins); };
        _this._createDataSetOfGVBC = function (points) {
            var keys = [];
            var xAxisLabels = points.map(function (singlePoint) { return singlePoint.name; });
            points[0].series.forEach(function (singleKey) {
                keys.push(singleKey.key);
            });
            var datasetForBars = _this._createDataset(points);
            return {
                keys: keys,
                xAxisLabels: xAxisLabels,
                datasetForBars: datasetForBars,
            };
        };
        _this._getCustomizedCallout = function () {
            return _this.props.onRenderCalloutPerDataPoint
                ? _this.props.onRenderCalloutPerDataPoint(_this.state.dataPointCalloutProps)
                : null;
        };
        _this._getOpacity = function (legendTitle) {
            var opacity = _this._legendHighlighted(legendTitle) || _this._noLegendHighlighted() ? '' : '0.1';
            return opacity;
        };
        _this._onBarHover = function (pointData, 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        groupData, mouseEvent) {
            mouseEvent.persist();
            if (_this._calloutAnchorPoint !== pointData) {
                _this._calloutAnchorPoint = pointData;
                _this.setState({
                    refSelected: mouseEvent,
                    /** Show the callout if highlighted bar is hovered and Hide it if unhighlighted bar is hovered */
                    isCalloutVisible: _this.state.selectedLegend === '' || _this.state.selectedLegend === pointData.legend,
                    calloutLegend: pointData.legend,
                    dataForHoverCard: pointData.data,
                    color: pointData.color,
                    xCalloutValue: pointData.xAxisCalloutData,
                    yCalloutValue: pointData.yAxisCalloutData,
                    dataPointCalloutProps: pointData,
                    callOutAccessibilityData: _this.props.isCalloutForStack
                        ? groupData.stackCallOutAccessibilityData
                        : pointData.callOutAccessibilityData,
                    YValueHover: groupData.groupSeries,
                    hoverXValue: pointData.xAxisCalloutData,
                });
            }
        };
        _this._onBarLeave = function () {
            /**/
        };
        _this._handleChartMouseLeave = function () {
            _this._calloutAnchorPoint = null;
            _this.setState({ isCalloutVisible: false });
        };
        _this._onBarFocus = function (pointData, 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        groupData, refArrayIndexNumber) {
            _this._refArray.forEach(function (obj, index) {
                if (obj.index === pointData.legend && refArrayIndexNumber === index) {
                    _this.setState({
                        refSelected: obj.refElement,
                        /** Show the callout if highlighted bar is focused and Hide it if unhighlighted bar is focused */
                        isCalloutVisible: _this.state.selectedLegend === '' || _this.state.selectedLegend === pointData.legend,
                        calloutLegend: pointData.legend,
                        dataForHoverCard: pointData.data,
                        color: pointData.color,
                        xCalloutValue: pointData.xAxisCalloutData,
                        yCalloutValue: pointData.yAxisCalloutData,
                        dataPointCalloutProps: pointData,
                        callOutAccessibilityData: _this.props.isCalloutForStack
                            ? groupData.stackCallOutAccessibilityData
                            : pointData.callOutAccessibilityData,
                        YValueHover: groupData.groupSeries,
                        hoverXValue: pointData.xAxisCalloutData,
                    });
                }
            });
        };
        _this._redirectToUrl = function (href) {
            href ? (window.location.href = href) : '';
        };
        _this._buildGraph = function (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        singleSet, 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        xScale0, 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        xScale1, containerHeight, xElement) {
            var singleGroup = [];
            var yBarScale = d3ScaleLinear()
                .domain([0, _this._yMax])
                .range([0, containerHeight - _this.margins.bottom - _this.margins.top]);
            var widthOfBar;
            if (_this.props.barwidth && _this.props.barwidth < xScale1.bandwidth()) {
                widthOfBar = _this.props.barwidth;
            }
            else {
                widthOfBar = xScale1.bandwidth();
            }
            var tempDataSet = Object.keys(_this._datasetForBars[0]).splice(0, _this._keys.length);
            tempDataSet.forEach(function (datasetKey, index) {
                var refIndexNumber = singleSet.indexNum * tempDataSet.length + index;
                var pointData = singleSet[datasetKey];
                // Not rendering data with 0.
                pointData.data &&
                    singleGroup.push(React.createElement("rect", { className: _this._classNames.opacityChangeOnHover, key: singleSet.indexNum + "-" + index, height: Math.max(yBarScale(pointData.data), 0), width: widthOfBar, x: xScale1(datasetKey), y: Math.max(containerHeight - _this.margins.bottom - yBarScale(pointData.data), 0), "data-is-focusable": !_this.props.hideTooltip, opacity: _this._getOpacity(pointData.legend), ref: function (e) {
                            _this._refCallback(e, pointData.legend, refIndexNumber);
                        }, fill: pointData.color, onMouseOver: _this._onBarHover.bind(_this, pointData, singleSet), onMouseMove: _this._onBarHover.bind(_this, pointData, singleSet), onMouseOut: _this._onBarLeave, onFocus: _this._onBarFocus.bind(_this, pointData, singleSet, refIndexNumber), onBlur: _this._onBarLeave, onClick: _this.props.href ? _this._redirectToUrl.bind(_this, _this.props.href) : pointData.onClick, "aria-label": _this._getAriaLabel(pointData, singleSet.xAxisPoint), role: "img" }));
            });
            // Used to display tooltip at x axis labels.
            if (!_this.props.wrapXAxisLables && _this.props.showXAxisLablesTooltip) {
                var xAxisElement = d3Select(xElement).call(xScale0);
                try {
                    document.getElementById(_this._tooltipId) && document.getElementById(_this._tooltipId).remove();
                    // eslint-disable-next-line no-empty
                }
                catch (e) { }
                var tooltipProps = {
                    tooltipCls: _this._classNames.tooltip,
                    id: _this._tooltipId,
                    xAxis: xAxisElement,
                };
                xAxisElement && tooltipOfXAxislabels(tooltipProps);
            }
            var customXScale = _this._isCustomBarWidth ? (xScale0.bandwidth() - _this._x1TotalBandWidth) / 2 : 0;
            return (React.createElement("g", { key: singleSet.indexNum, transform: "translate(" + (xScale0(singleSet.xAxisPoint) + customXScale) + ", 0)" }, singleGroup));
        };
        _this._createDataset = function (points) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var datasetForBars = [];
            var dataset = [];
            points.forEach(function (point, index) {
                var singleDatasetPoint = {};
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var singleDatasetPointForBars = {};
                var singleDataSeries = [];
                point.series.forEach(function (seriesPoint) {
                    singleDatasetPoint[seriesPoint.key] = seriesPoint.data;
                    singleDatasetPointForBars[seriesPoint.key] = __assign({}, seriesPoint);
                    singleDataSeries.push(seriesPoint);
                });
                singleDatasetPointForBars.xAxisPoint = point.name;
                singleDatasetPointForBars.indexNum = index;
                singleDatasetPointForBars.groupSeries = singleDataSeries;
                singleDatasetPointForBars.stackCallOutAccessibilityData = point.stackCallOutAccessibilityData;
                datasetForBars.push(singleDatasetPointForBars);
                dataset.push(singleDatasetPoint);
            });
            _this._dataset = dataset;
            return datasetForBars;
        };
        // For grouped vertical bar chart, First need to define total scale (from start to end)
        // From that need to define scale for single group of bars - done by createX1Scale
        _this._createX0Scale = function (containerWidth) {
            var x0Axis = d3ScaleBand()
                .domain(_this._xAxisLabels)
                .range(_this._isRtl
                ? [containerWidth - _this.margins.right, _this.margins.left]
                : [_this.margins.left, containerWidth - _this.margins.right])
                .padding(0.1);
            return x0Axis;
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        _this._createX1Scale = function (xScale0) {
            var bandWidth = xScale0.bandwidth();
            if (_this.props.barwidth) {
                var tempDataSet = Object.keys(_this._datasetForBars[0]).splice(0, _this._keys.length);
                var totalWidth = (_this.props.barwidth + BAR_SPACE) * tempDataSet.length;
                _this._isCustomBarWidth = totalWidth < xScale0.bandwidth();
                bandWidth = _this._isCustomBarWidth ? totalWidth : xScale0.bandwidth();
                _this._x1TotalBandWidth = bandWidth;
            }
            return d3ScaleBand()
                .domain(_this._keys)
                .range(_this._isRtl ? [bandWidth, 0] : [0, bandWidth])
                .padding(0.05);
        };
        _this._closeCallout = function () {
            _this.setState({
                isCalloutVisible: false,
            });
        };
        _this._getLegendData = function (points, palette) {
            var data = points;
            var defaultPalette = [palette.blueLight, palette.blue, palette.blueMid, palette.red, palette.black];
            var actions = [];
            data.forEach(function (singleChartData) {
                singleChartData.series.forEach(function (point) {
                    var color = point.color ? point.color : defaultPalette[Math.floor(Math.random() * 4 + 1)];
                    var checkSimilarLegends = actions.filter(function (leg) { return leg.title === point.legend && leg.color === color; });
                    if (checkSimilarLegends.length > 0) {
                        return;
                    }
                    var legend = {
                        title: point.legend,
                        color: color,
                        action: function () {
                            _this._onLegendClick(point.legend);
                        },
                        hoverAction: function () {
                            _this._handleChartMouseLeave();
                            _this._onLegendHover(point.legend);
                        },
                        onMouseOutAction: function () {
                            _this._onLegendLeave();
                        },
                    };
                    actions.push(legend);
                });
            });
            return (React.createElement(Legends, __assign({ legends: actions, overflowProps: _this.props.legendsOverflowProps, enabledWrapLines: _this.props.enabledLegendsWrapLines, focusZonePropsInHoverCard: _this.props.focusZonePropsForLegendsInHoverCard }, _this.props.legendProps)));
        };
        _this._getAxisData = function (yAxisData) {
            if (yAxisData && yAxisData.yAxisDomainValues.length) {
                var domainValue = yAxisData.yAxisDomainValues;
                _this._yMax = Math.max(domainValue[domainValue.length - 1], _this.props.yMaxValue || 0);
            }
        };
        /**
         * This function checks if the given legend is highlighted or not.
         * A legend can be highlighted in 2 ways:
         * 1. selection: if the user clicks on it
         * 2. hovering: if there is no selected legend and the user hovers over it
         */
        _this._legendHighlighted = function (legendTitle) {
            return (_this.state.selectedLegend === legendTitle ||
                (_this.state.selectedLegend === '' && _this.state.activeLegend === legendTitle));
        };
        /**
         * This function checks if none of the legends is selected or hovered.
         */
        _this._noLegendHighlighted = function () {
            return _this.state.selectedLegend === '' && _this.state.activeLegend === '';
        };
        _this._getAriaLabel = function (point, xAxisPoint) {
            var _a;
            var xValue = point.xAxisCalloutData || xAxisPoint;
            var legend = point.legend;
            var yValue = point.yAxisCalloutData || point.data;
            return ((_a = point.callOutAccessibilityData) === null || _a === void 0 ? void 0 : _a.ariaLabel) || xValue + ". " + legend + ", " + yValue + ".";
        };
        _this._createSet = memoizeFunction(function (data) { return _this._createDataSetOfGVBC(data); });
        _this.state = {
            color: '',
            dataForHoverCard: 0,
            isCalloutVisible: false,
            refSelected: null,
            selectedLegend: '',
            xCalloutValue: '',
            yCalloutValue: '',
            YValueHover: [],
            hoverXValue: '',
            calloutLegend: '',
            activeLegend: '',
        };
        warnDeprecations(COMPONENT_NAME, props, {
            showYAxisGridLines: 'Dont use this property. Lines are drawn by default',
            showXAxisPath: 'Dont use this property. Axis line removed default.',
            showYAxisPath: 'Dont use this property. No need to display Y axis path. Handling default',
            showXAxisGridLines: 'Dont use this property. Handling with default value.',
            legendColor: 'Dont use this property. colour will pick from given data.',
        });
        _this._refArray = [];
        _this._calloutId = getId('callout');
        _this._tooltipId = getId('GVBCTooltipId_');
        return _this;
    }
    GroupedVerticalBarChartBase.prototype.render = function () {
        var _this = this;
        var points = this.props.data;
        var _a = this._createSet(points), keys = _a.keys, xAxisLabels = _a.xAxisLabels, datasetForBars = _a.datasetForBars;
        this._keys = keys;
        this._xAxisLabels = xAxisLabels;
        this._datasetForBars = datasetForBars;
        this._isNumeric = getTypeOfAxis(points[0].name, true);
        var legends = this._getLegendData(points, this.props.theme.palette);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var yMax = d3Max(this._dataset, function (point) { return d3Max(_this._keys, function (key) { return point[key]; }); });
        this._yMax = Math.max(yMax, this.props.yMaxValue || 0);
        this._classNames = getClassNames(this.props.styles, {
            theme: this.props.theme,
            href: this.props.href,
        });
        var calloutProps = __assign(__assign(__assign({ target: this.state.refSelected, isCalloutVisible: this.state.isCalloutVisible, directionalHint: DirectionalHint.topAutoEdge, id: "toolTip" + this._calloutId, gapSpace: 15, isBeakVisible: false, setInitialFocus: true, color: this.state.color, Legend: this.state.calloutLegend, XValue: this.state.xCalloutValue, YValue: this.state.yCalloutValue ? this.state.yCalloutValue : this.state.dataForHoverCard, YValueHover: this.state.YValueHover, hoverXValue: this.state.hoverXValue, onDismiss: this._closeCallout }, this.props.calloutProps), { preventDismissOnLostFocus: true }), getAccessibleDataObject(this.state.callOutAccessibilityData, 'text', false));
        var tickParams = {
            tickValues: this.props.tickValues,
            tickFormat: this.props.tickFormat,
        };
        return (React.createElement(CartesianChart, __assign({}, this.props, { points: this._datasetForBars, chartType: ChartTypes.GroupedVerticalBarChart, calloutProps: calloutProps, legendBars: legends, xAxisType: this._isNumeric, datasetForXAxisDomain: this._xAxisLabels, tickParams: tickParams, tickPadding: this.props.tickPadding || 5, maxOfYVal: this._yMax, svgFocusZoneProps: {
                direction: FocusZoneDirection.horizontal,
            }, customizedCallout: this._getCustomizedCallout(), getmargins: this._getMargins, getGraphData: this._getGraphData, getAxisData: this._getAxisData, onChartMouseLeave: this._handleChartMouseLeave, 
            /* eslint-disable react/jsx-no-bind */
            // eslint-disable-next-line react/no-children-prop
            children: function () {
                return React.createElement("g", null, _this._groupedVerticalBarGraph);
            } })));
    };
    GroupedVerticalBarChartBase.prototype._refCallback = function (element, legendTitle, refIndexNumber) {
        this._refArray[refIndexNumber] = { index: legendTitle, refElement: element };
    };
    GroupedVerticalBarChartBase.prototype._onLegendClick = function (legendTitle) {
        if (this.state.selectedLegend === legendTitle) {
            this.setState({
                selectedLegend: '',
            });
        }
        else {
            this.setState({
                selectedLegend: legendTitle,
            });
        }
    };
    GroupedVerticalBarChartBase.prototype._onLegendHover = function (legendTitle) {
        this.setState({
            activeLegend: legendTitle,
        });
    };
    GroupedVerticalBarChartBase.prototype._onLegendLeave = function () {
        this.setState({
            activeLegend: '',
        });
    };
    return GroupedVerticalBarChartBase;
}(React.Component));
export { GroupedVerticalBarChartBase };
//# sourceMappingURL=GroupedVerticalBarChart.base.js.map