import { __assign, __extends } from "tslib";
import * as React from 'react';
import { classNamesFunction, getId } from '@fluentui/react/lib/Utilities';
import { Legends } from '../Legends/index';
import { Callout, DirectionalHint } from '@fluentui/react/lib/Callout';
import { FocusZone, FocusZoneDirection } from '@fluentui/react-focus';
import { ChartHoverCard, convertToLocaleString, getAccessibleDataObject } from '../../utilities/index';
import { TooltipHost, TooltipOverflowMode } from '@fluentui/react';
var getClassNames = classNamesFunction();
var MultiStackedBarChartBase = /** @class */ (function (_super) {
    __extends(MultiStackedBarChartBase, _super);
    function MultiStackedBarChartBase(props) {
        var _this = _super.call(this, props) || this;
        _this._adjustProps = function () {
            var _a = _this.props, theme = _a.theme, className = _a.className, styles = _a.styles, width = _a.width, barHeight = _a.barHeight;
            _this._classNames = getClassNames(styles, {
                legendColor: _this.state.color,
                theme: theme,
                width: width,
                className: className,
                barHeight: barHeight,
            });
        };
        _this._getLegendData = function (data, hideRatio, palette) {
            var defaultPalette = [palette.blueLight, palette.blue, palette.blueMid, palette.red, palette.black];
            var actions = [];
            data.forEach(function (singleChartData, index) {
                var validChartData = singleChartData.chartData.filter(function (_) { return !_.placeHolder; });
                if (validChartData.length < 3) {
                    var hideNumber = hideRatio[index] === undefined ? false : hideRatio[index];
                    if (hideNumber) {
                        validChartData.forEach(function (point) {
                            var color = point.color ? point.color : defaultPalette[Math.floor(Math.random() * 4 + 1)];
                            var checkSimilarLegends = actions.filter(function (leg) { return leg.title === point.legend && leg.color === color; });
                            if (checkSimilarLegends.length > 0) {
                                return;
                            }
                            var legend = {
                                title: point.legend,
                                color: color,
                                action: function () {
                                    _this._onClick(point.legend);
                                },
                                hoverAction: function () {
                                    _this._handleChartMouseLeave();
                                    _this._onHover(point.legend);
                                },
                                onMouseOutAction: function () {
                                    _this._onLeave();
                                },
                            };
                            actions.push(legend);
                        });
                    }
                }
                else {
                    validChartData.forEach(function (point) {
                        var color = point.color ? point.color : defaultPalette[Math.floor(Math.random() * 4 + 1)];
                        var checkSimilarLegends = actions.filter(function (leg) { return leg.title === point.legend && leg.color === color; });
                        if (checkSimilarLegends.length > 0) {
                            return;
                        }
                        var legend = {
                            title: point.legend,
                            color: color,
                            action: function () {
                                _this._onClick(point.legend);
                            },
                            hoverAction: function () {
                                _this._handleChartMouseLeave();
                                _this._onHover(point.legend);
                            },
                            onMouseOutAction: function () {
                                _this._onLeave();
                            },
                        };
                        actions.push(legend);
                    });
                }
            });
            return (React.createElement(Legends, __assign({ legends: actions, overflowProps: _this.props.legendsOverflowProps, focusZonePropsInHoverCard: _this.props.focusZonePropsForLegendsInHoverCard, overflowText: _this.props.legendsOverflowText }, _this.props.legendProps)));
        };
        _this._handleChartMouseLeave = function () {
            _this._calloutAnchorPoint = null;
            _this.setState({
                isCalloutVisible: false,
            });
        };
        _this._closeCallout = function () {
            _this.setState({
                isCalloutVisible: false,
            });
        };
        /**
         * This function checks if the given legend is highlighted or not.
         * A legend can be highlighted in 2 ways:
         * 1. selection: if the user clicks on it
         * 2. hovering: if there is no selected legend and the user hovers over it
         */
        _this._legendHighlighted = function (legendTitle) {
            return (_this.state.selectedLegend === legendTitle ||
                (_this.state.selectedLegend === '' && _this.state.activeLegend === legendTitle));
        };
        /**
         * This function checks if none of the legends is selected or hovered.
         */
        _this._noLegendHighlighted = function () {
            return _this.state.selectedLegend === '' && _this.state.activeLegend === '';
        };
        _this._getAriaLabel = function (point) {
            var _a;
            var legend = point.xAxisCalloutData || point.legend;
            var yValue = point.yAxisCalloutData || point.data || 0;
            return ((_a = point.callOutAccessibilityData) === null || _a === void 0 ? void 0 : _a.ariaLabel) || (legend ? legend + ", " : '') + (yValue + ".");
        };
        _this.state = {
            isCalloutVisible: false,
            refArray: [],
            selectedLegend: '',
            activeLegend: '',
            refSelected: null,
            dataForHoverCard: 0,
            color: '',
            xCalloutValue: '',
            yCalloutValue: '',
            calloutLegend: '',
        };
        _this._onLeave = _this._onLeave.bind(_this);
        _this._onBarLeave = _this._onBarLeave.bind(_this);
        _this._calloutId = getId('callout');
        return _this;
    }
    MultiStackedBarChartBase.prototype.render = function () {
        var _this = this;
        var _a = this.props, data = _a.data, theme = _a.theme, culture = _a.culture;
        this._adjustProps();
        var palette = theme.palette;
        var legends = this._getLegendData(data, this.props.hideRatio, palette);
        var isCalloutVisible = this.state.isCalloutVisible;
        this._classNames = getClassNames(this.props.styles, {
            legendColor: this.state.color,
            theme: theme,
        });
        var legendName = this.state.xCalloutValue ? this.state.xCalloutValue : this.state.calloutLegend;
        var calloutYVal = this.state.yCalloutValue ? this.state.yCalloutValue : this.state.dataForHoverCard;
        var bars = data.map(function (singleChartData, index) {
            var singleChartBars = _this._createBarsAndLegends(singleChartData, _this.props.barHeight, palette, _this.props.hideRatio[index], _this.props.hideDenominator[index], _this.props.href);
            return React.createElement("div", { key: index }, singleChartBars);
        });
        return (React.createElement("div", { className: this._classNames.root, onMouseLeave: this._handleChartMouseLeave },
            bars,
            !this.props.hideLegend && React.createElement("div", { className: this._classNames.legendContainer }, legends),
            React.createElement(Callout, __assign({ gapSpace: 15, isBeakVisible: false, target: this.state.refSelected, setInitialFocus: true, hidden: !(!this.props.hideTooltip && isCalloutVisible), directionalHint: DirectionalHint.topAutoEdge, id: this._calloutId, onDismiss: this._closeCallout, preventDismissOnLostFocus: true, 
                /** Keep the callout updated with details of focused/hovered bar */
                shouldUpdateWhenHidden: true }, this.props.calloutProps, getAccessibleDataObject(this.state.callOutAccessibilityData, 'text', false)),
                React.createElement(React.Fragment, null, this.props.onRenderCalloutPerDataPoint ? (this.props.onRenderCalloutPerDataPoint(this.state.dataPointCalloutProps)) : (React.createElement(ChartHoverCard, { Legend: legendName, YValue: calloutYVal, color: this.state.color, culture: culture }))))));
    };
    MultiStackedBarChartBase.prototype._createBarsAndLegends = function (data, barHeight, palette, hideRatio, hideDenominator, href) {
        var _this = this;
        var culture = this.props.culture;
        var defaultPalette = [palette.blueLight, palette.blue, palette.blueMid, palette.red, palette.black];
        // calculating starting point of each bar and it's range
        var startingPoint = [];
        var total = data.chartData.reduce(function (acc, point) { return acc + (point.data ? point.data : 0); }, 0);
        var sumOfPercent = 0;
        data.chartData.map(function (point, index) {
            var pointData = point.data ? point.data : 0;
            value = (pointData / total) * 100 ? (pointData / total) * 100 : 0;
            if (value < 1 && value !== 0) {
                value = 1;
            }
            else if (value > 99 && value !== 100) {
                value = 99;
            }
            sumOfPercent += value;
            return sumOfPercent;
        });
        var scalingRatio = sumOfPercent !== 0 ? sumOfPercent / 100 : 1;
        var prevPosition = 0;
        var value = 0;
        var bars = data.chartData.map(function (point, index) {
            var color = point.color
                ? point.color
                : point.placeHolder
                    ? palette.neutralLight
                    : defaultPalette[Math.floor(Math.random() * 4 + 1)];
            var pointData = point.data ? point.data : 0;
            if (index > 0) {
                prevPosition += value;
            }
            value = (pointData / total) * 100 ? (pointData / total) * 100 : 0;
            if (value < 1 && value !== 0) {
                value = 1 / scalingRatio;
            }
            else if (value > 99 && value !== 100) {
                value = 99 / scalingRatio;
            }
            else {
                value = value / scalingRatio;
            }
            startingPoint.push(prevPosition);
            var styles = _this.props.styles;
            var shouldHighlight = _this._legendHighlighted(point.legend) || _this._noLegendHighlighted() ? true : false;
            _this._classNames = getClassNames(styles, {
                theme: _this.props.theme,
                shouldHighlight: shouldHighlight,
                href: href,
            });
            return (React.createElement("g", { key: index, className: point.placeHolder ? _this._classNames.placeHolderOnHover : _this._classNames.opacityChangeOnHover, ref: function (e) {
                    _this._refCallback(e, point.legend);
                }, "data-is-focusable": !_this.props.hideTooltip, onFocus: _this._onBarFocus.bind(_this, pointData, color, point), onBlur: _this._onBarLeave, role: "img", "aria-label": _this._getAriaLabel(point), onMouseOver: point.placeHolder ? undefined : _this._onBarHover.bind(_this, pointData, color, point), onMouseMove: point.placeHolder ? undefined : _this._onBarHover.bind(_this, pointData, color, point), onMouseLeave: point.placeHolder ? undefined : _this._onBarLeave, onClick: href ? (point.placeHolder ? undefined : _this._redirectToUrl.bind(_this, href)) : point.onClick },
                React.createElement("rect", { key: index, x: startingPoint[index] + '%', y: 0, width: value + '%', height: barHeight, fill: color })));
        });
        if (data.chartData.length === 0) {
            bars.push(React.createElement("g", { key: 0, className: this._classNames.noData, onClick: this._redirectToUrl.bind(this, href) },
                React.createElement("rect", { key: 0, x: '0%', y: 0, width: '100%', height: barHeight, fill: palette.neutralLight })));
        }
        if (total === 0) {
            bars.push(React.createElement("g", { key: 'empty', className: this._classNames.noData, onClick: this._redirectToUrl.bind(this, href) },
                React.createElement("rect", { key: 0, x: '0%', y: 0, width: '100%', height: barHeight, fill: palette.neutralLight })));
        }
        var hideNumber = hideRatio === undefined ? false : hideRatio;
        var showRatio = !hideNumber && data.chartData.length === 2;
        var showNumber = !hideNumber && data.chartData.length === 1;
        var getChartData = function () { return convertToLocaleString(data.chartData[0].data ? data.chartData[0].data : 0, culture); };
        return (React.createElement("div", { className: this._classNames.singleChartRoot },
            React.createElement(FocusZone, { direction: FocusZoneDirection.horizontal },
                React.createElement("div", { className: this._classNames.chartTitle },
                    data.chartTitle && (React.createElement(TooltipHost, { overflowMode: TooltipOverflowMode.Self, hostClassName: this._classNames.chartTitleLeft, content: data.chartTitle },
                        React.createElement("span", __assign({}, getAccessibleDataObject(data.chartTitleAccessibilityData)), data.chartTitle))),
                    showRatio && (React.createElement("div", __assign({}, getAccessibleDataObject(data.chartDataAccessibilityData)),
                        React.createElement("span", { className: this._classNames.ratioNumerator }, getChartData()),
                        !hideDenominator && (React.createElement("span", { className: this._classNames.ratioDenominator }, ' / ' + convertToLocaleString(total, culture))))),
                    showNumber && (React.createElement("div", __assign({ className: this._classNames.ratioNumerator }, getAccessibleDataObject(data.chartDataAccessibilityData)), getChartData())))),
            React.createElement(FocusZone, { direction: FocusZoneDirection.horizontal },
                React.createElement("div", null,
                    React.createElement("svg", { className: this._classNames.chart, "aria-label": data === null || data === void 0 ? void 0 : data.chartTitle }, bars)))));
    };
    MultiStackedBarChartBase.prototype._onBarFocus = function (pointData, color, point) {
        var _this = this;
        this.state.refArray.forEach(function (obj) {
            if (obj.legendText === point.legend) {
                _this.setState({
                    refSelected: obj.refElement,
                    /** Show the callout if highlighted bar is focused and Hide it if unhighlighted bar is focused */
                    isCalloutVisible: _this.state.selectedLegend === '' || _this.state.selectedLegend === point.legend,
                    calloutLegend: point.legend,
                    dataForHoverCard: pointData,
                    color: color,
                    xCalloutValue: point.xAxisCalloutData,
                    yCalloutValue: point.yAxisCalloutData,
                    dataPointCalloutProps: point,
                    callOutAccessibilityData: point.callOutAccessibilityData,
                });
            }
        });
    };
    MultiStackedBarChartBase.prototype._refCallback = function (element, legendTitle) {
        this.state.refArray.push({ legendText: legendTitle, refElement: element });
    };
    MultiStackedBarChartBase.prototype._onHover = function (legendTitle) {
        this.setState({
            activeLegend: legendTitle,
        });
    };
    MultiStackedBarChartBase.prototype._onClick = function (legendTitle) {
        if (this.state.selectedLegend === legendTitle) {
            this.setState({
                selectedLegend: '',
            });
        }
        else {
            this.setState({
                selectedLegend: legendTitle,
            });
        }
    };
    MultiStackedBarChartBase.prototype._onLeave = function () {
        this.setState({
            activeLegend: '',
        });
    };
    MultiStackedBarChartBase.prototype._onBarHover = function (pointData, color, point, mouseEvent) {
        mouseEvent.persist();
        if (this._calloutAnchorPoint !== point) {
            this._calloutAnchorPoint = point;
            this.setState({
                refSelected: mouseEvent,
                /** Show the callout if highlighted bar is hovered and Hide it if unhighlighted bar is hovered */
                isCalloutVisible: this.state.selectedLegend === '' || this.state.selectedLegend === point.legend,
                calloutLegend: point.legend,
                dataForHoverCard: pointData,
                color: color,
                xCalloutValue: point.xAxisCalloutData,
                yCalloutValue: point.yAxisCalloutData,
                dataPointCalloutProps: point,
                callOutAccessibilityData: point.callOutAccessibilityData,
            });
        }
    };
    MultiStackedBarChartBase.prototype._onBarLeave = function () {
        /**/
    };
    MultiStackedBarChartBase.prototype._redirectToUrl = function (href) {
        href ? (window.location.href = href) : '';
    };
    MultiStackedBarChartBase.defaultProps = {
        barHeight: 12,
        hideRatio: [],
        hideDenominator: [],
    };
    return MultiStackedBarChartBase;
}(React.Component));
export { MultiStackedBarChartBase };
//# sourceMappingURL=MultiStackedBarChart.base.js.map