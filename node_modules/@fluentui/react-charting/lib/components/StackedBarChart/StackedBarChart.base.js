import { __assign, __extends } from "tslib";
import * as React from 'react';
import { classNamesFunction, getId } from '@fluentui/react/lib/Utilities';
import { Legends } from '../Legends/index';
import { Callout, DirectionalHint } from '@fluentui/react/lib/Callout';
import { FocusZone, FocusZoneDirection } from '@fluentui/react-focus';
import { ChartHoverCard, convertToLocaleString, getAccessibleDataObject } from '../../utilities/index';
import { TooltipHost, TooltipOverflowMode } from '@fluentui/react';
var getClassNames = classNamesFunction();
var StackedBarChartBase = /** @class */ (function (_super) {
    __extends(StackedBarChartBase, _super);
    function StackedBarChartBase(props) {
        var _this = _super.call(this, props) || this;
        _this._handleChartMouseLeave = function () {
            _this._calloutAnchorPoint = null;
            _this.setState({
                isCalloutVisible: false,
            });
        };
        _this._closeCallout = function () {
            _this.setState({
                isCalloutVisible: false,
            });
        };
        /**
         * This function checks if the given legend is highlighted or not.
         * A legend can be highlighted in 2 ways:
         * 1. selection: if the user clicks on it
         * 2. hovering: if there is no selected legend and the user hovers over it
         */
        _this._legendHighlighted = function (legendTitle) {
            return (_this.state.selectedLegend === legendTitle ||
                (_this.state.selectedLegend === '' && _this.state.activeLegend === legendTitle));
        };
        /**
         * This function checks if none of the legends is selected or hovered.
         */
        _this._noLegendHighlighted = function () {
            return _this.state.selectedLegend === '' && _this.state.activeLegend === '';
        };
        _this._getAriaLabel = function (point) {
            var _a;
            var legend = point.xAxisCalloutData || point.legend;
            var yValue = point.yAxisCalloutData || point.data || 0;
            return ((_a = point.callOutAccessibilityData) === null || _a === void 0 ? void 0 : _a.ariaLabel) || (legend ? legend + ", " : '') + (yValue + ".");
        };
        _this.state = {
            isCalloutVisible: false,
            selectedLegend: '',
            activeLegend: '',
            refSelected: null,
            dataForHoverCard: 0,
            color: '',
            xCalloutValue: '',
            yCalloutValue: '',
            calloutLegend: '',
        };
        _this._refArray = [];
        _this._onLeave = _this._onLeave.bind(_this);
        _this._refCallback = _this._refCallback.bind(_this);
        _this._onBarLeave = _this._onBarLeave.bind(_this);
        _this._calloutId = getId('callout');
        return _this;
    }
    StackedBarChartBase.prototype.render = function () {
        this._adjustProps();
        var _a = this.props, data = _a.data, benchmarkData = _a.benchmarkData, targetData = _a.targetData, hideNumberDisplay = _a.hideNumberDisplay, ignoreFixStyle = _a.ignoreFixStyle, culture = _a.culture;
        var palette = this.props.theme.palette;
        var barHeight = ignoreFixStyle || data.chartData.length > 2 ? this.props.barHeight : 12;
        if (benchmarkData) {
            // benchmark color is used to render color for benchmark triangle and benchmark legend
            benchmarkData.color = benchmarkData.color || palette.neutralTertiary;
        }
        if (targetData) {
            // target color is used to render color for target triangle and target legend
            targetData.color = targetData.color || palette.neutralSecondary;
        }
        var bars = this._createBarsAndLegends(data, barHeight, palette, benchmarkData, targetData);
        var showRatio = hideNumberDisplay === false && !ignoreFixStyle && data.chartData.length === 2;
        var showNumber = hideNumberDisplay === false && !ignoreFixStyle && data.chartData.length === 1;
        var total = data.chartData.reduce(function (acc, value) { return acc + (value.data ? value.data : 0); }, 0);
        var benchmarkRatio = 0;
        if (benchmarkData && total) {
            benchmarkRatio = (benchmarkData.data / total) * 100;
        }
        var targetRatio = 0;
        if (targetData && total) {
            targetRatio = (targetData.data / total) * 100;
        }
        var showLegend = this.props.hideLegend === false && (ignoreFixStyle || data.chartData.length > 2);
        this._classNames = getClassNames(this.props.styles, {
            legendColor: this.state.color,
            theme: this.props.theme,
            benchmarkColor: benchmarkData ? benchmarkData.color : '',
            benchmarkRatio: benchmarkRatio,
            targetColor: targetData ? targetData.color : '',
            targetRatio: targetRatio,
            showTriangle: !!(benchmarkData || targetData),
        });
        var getChartData = function () { return convertToLocaleString(data.chartData[0].data ? data.chartData[0].data : 0, culture); };
        return (React.createElement("div", { className: this._classNames.root, onMouseLeave: this._handleChartMouseLeave },
            React.createElement(FocusZone, { direction: FocusZoneDirection.horizontal },
                React.createElement("div", { className: this._classNames.chartTitle },
                    data.chartTitle && (React.createElement(TooltipHost, { overflowMode: TooltipOverflowMode.Self, hostClassName: this._classNames.chartTitleLeft, content: data.chartTitle },
                        React.createElement("span", __assign({}, getAccessibleDataObject(data.chartTitleAccessibilityData)), data.chartTitle))),
                    showRatio && (React.createElement("div", __assign({}, getAccessibleDataObject(data.chartDataAccessibilityData)),
                        React.createElement("span", { className: this._classNames.ratioNumerator }, getChartData()),
                        !this.props.hideDenominator && (React.createElement("span", { className: this._classNames.ratioDenominator }, ' / ' + convertToLocaleString(total, culture))))),
                    showNumber && (React.createElement("div", __assign({ className: this._classNames.ratioNumerator }, getAccessibleDataObject(data.chartDataAccessibilityData)), getChartData()))),
                (benchmarkData || targetData) && (React.createElement("div", { className: this._classNames.benchmarkContainer },
                    benchmarkData && React.createElement("div", { className: this._classNames.benchmark, role: "text" }),
                    targetData && React.createElement("div", { className: this._classNames.target, role: "text" })))),
            React.createElement(FocusZone, { direction: FocusZoneDirection.horizontal },
                React.createElement("div", null,
                    React.createElement("svg", { className: this._classNames.chart, "aria-label": data === null || data === void 0 ? void 0 : data.chartTitle },
                        React.createElement("g", null, bars[0]),
                        React.createElement(Callout, __assign({ gapSpace: 15, isBeakVisible: false, target: this.state.refSelected, setInitialFocus: true, hidden: !(!this.props.hideTooltip && this.state.isCalloutVisible), directionalHint: DirectionalHint.topAutoEdge, id: this._calloutId, onDismiss: this._closeCallout, preventDismissOnLostFocus: true, 
                            /** Keep the callout updated with details of focused/hovered bar */
                            shouldUpdateWhenHidden: true }, this.props.calloutProps, getAccessibleDataObject(this.state.callOutAccessibilityData, 'text', false)),
                            React.createElement(React.Fragment, null, this.props.onRenderCalloutPerDataPoint ? (this.props.onRenderCalloutPerDataPoint(this.state.dataPointCalloutProps)) : (React.createElement(ChartHoverCard, { Legend: this.state.xCalloutValue ? this.state.xCalloutValue : this.state.calloutLegend, YValue: this.state.yCalloutValue ? this.state.yCalloutValue : this.state.dataForHoverCard, color: this.state.color, culture: culture }))))))),
            showLegend && React.createElement("div", { className: this._classNames.legendContainer }, bars[1])));
    };
    StackedBarChartBase.prototype._adjustProps = function () {
        this._classNames = getClassNames(this.props.styles, {
            legendColor: this.state.color,
            theme: this.props.theme,
            width: this.props.width,
            barHeight: this.props.barHeight,
            className: this.props.className,
        });
    };
    StackedBarChartBase.prototype._createBarsAndLegends = function (data, barHeight, palette, benchmarkData, targetData) {
        var _this = this;
        var defaultPalette = [palette.blueLight, palette.blue, palette.blueMid, palette.red, palette.black];
        var legendDataItems = [];
        // calculating starting point of each bar and it's range
        var startingPoint = [];
        var total = data.chartData.reduce(function (acc, point) { return acc + (point.data ? point.data : 0); }, 0);
        var prevPosition = 0;
        var value = 0;
        var sumOfPercent = 0;
        data.chartData.map(function (point, index) {
            var pointData = point.data ? point.data : 0;
            value = (pointData / total) * 100;
            if (value < 1 && value !== 0) {
                value = 1;
            }
            else if (value > 99 && value !== 100) {
                value = 99;
            }
            sumOfPercent += value;
            return sumOfPercent;
        });
        var scalingRatio = sumOfPercent !== 0 ? sumOfPercent / 100 : 1;
        var bars = data.chartData.map(function (point, index) {
            var color = point.color ? point.color : defaultPalette[Math.floor(Math.random() * 4 + 1)];
            var pointData = point.data ? point.data : 0;
            // mapping data to the format Legends component needs
            var legend = {
                title: point.legend,
                color: color,
                action: total > 0
                    ? function () {
                        _this._onClick(point.legend);
                    }
                    : undefined,
                hoverAction: total > 0
                    ? function () {
                        _this._handleChartMouseLeave();
                        _this._onHover(point.legend);
                    }
                    : undefined,
                onMouseOutAction: total > 0
                    ? function () {
                        _this._onLeave();
                    }
                    : undefined,
            };
            if (!point.placeHolder) {
                legendDataItems.push(legend);
            }
            if (index > 0) {
                prevPosition += value;
            }
            value = (pointData / total) * 100;
            if (value < 1 && value !== 0) {
                value = 1 / scalingRatio;
            }
            else if (value > 99 && value !== 100) {
                value = 99 / scalingRatio;
            }
            else {
                value = value / scalingRatio;
            }
            startingPoint.push(prevPosition);
            var styles = _this.props.styles;
            var shouldHighlight = _this._legendHighlighted(point.legend) || _this._noLegendHighlighted() ? true : false;
            _this._classNames = getClassNames(styles, {
                theme: _this.props.theme,
                shouldHighlight: shouldHighlight,
                href: _this.props.href,
            });
            return (React.createElement("g", { key: index, className: _this._classNames.opacityChangeOnHover, ref: function (e) {
                    _this._refCallback(e, legend.title);
                }, "data-is-focusable": !_this.props.hideTooltip, onFocus: _this._onBarFocus.bind(_this, pointData, color, point), onBlur: _this._onBarLeave, "aria-label": _this._getAriaLabel(point), role: "img", onMouseOver: _this._onBarHover.bind(_this, pointData, color, point), onMouseMove: _this._onBarHover.bind(_this, pointData, color, point), onMouseLeave: _this._onBarLeave, pointerEvents: "all", onClick: _this.props.href ? _this._redirectToUrl.bind(_this, _this.props.href) : point.onClick },
                React.createElement("rect", { key: index, x: startingPoint[index] + '%', y: 0, width: value + '%', height: barHeight, fill: color })));
        });
        // add benchmark legends
        this._addLegend(legendDataItems, benchmarkData);
        this._addLegend(legendDataItems, targetData);
        var legends = (React.createElement(Legends, __assign({ legends: legendDataItems, enabledWrapLines: this.props.enabledLegendsWrapLines, overflowProps: this.props.legendsOverflowProps, focusZonePropsInHoverCard: this.props.focusZonePropsForLegendsInHoverCard, overflowText: this.props.legendsOverflowText }, this.props.legendProps)));
        return [
            total === 0
                ? [
                    this._generateEmptyBar(barHeight, this.props.barBackgroundColor ? this.props.barBackgroundColor : palette.neutralLight),
                ]
                : bars,
            legends,
        ];
    };
    StackedBarChartBase.prototype._onBarFocus = function (pointData, color, point) {
        var _this = this;
        this._refArray.forEach(function (obj) {
            if (obj.index === point.legend) {
                _this.setState({
                    refSelected: obj.refElement,
                    /** Show the callout if highlighted bar is focused and Hide it if unhighlighted bar is focused */
                    isCalloutVisible: _this.state.selectedLegend === '' || _this.state.selectedLegend === point.legend,
                    calloutLegend: point.legend,
                    dataForHoverCard: pointData,
                    color: color,
                    xCalloutValue: point.xAxisCalloutData,
                    yCalloutValue: point.yAxisCalloutData,
                    dataPointCalloutProps: point,
                    callOutAccessibilityData: point.callOutAccessibilityData,
                });
            }
        });
    };
    StackedBarChartBase.prototype._addLegend = function (legendDataItems, data) {
        if (data) {
            var legend = {
                title: data.legend,
                color: data.color,
                shape: 'triangle',
            };
            legendDataItems.push(legend);
        }
    };
    StackedBarChartBase.prototype._generateEmptyBar = function (barHeight, color) {
        return (React.createElement("g", { key: 0, className: this._classNames.opacityChangeOnHover },
            React.createElement("rect", { key: 0, x: '0%', y: 0, width: '100%', height: barHeight, fill: color })));
    };
    StackedBarChartBase.prototype._refCallback = function (element, legendTitle) {
        this._refArray.push({ index: legendTitle, refElement: element });
    };
    StackedBarChartBase.prototype._onClick = function (legendTitle) {
        if (this.state.selectedLegend === legendTitle) {
            this.setState({
                selectedLegend: '',
            });
        }
        else {
            this.setState({
                selectedLegend: legendTitle,
            });
        }
    };
    StackedBarChartBase.prototype._onHover = function (legendTitle) {
        this.setState({
            activeLegend: legendTitle,
        });
    };
    StackedBarChartBase.prototype._onLeave = function () {
        this.setState({
            activeLegend: '',
        });
    };
    StackedBarChartBase.prototype._onBarHover = function (pointData, color, point, mouseEvent) {
        mouseEvent.persist();
        if (this._calloutAnchorPoint !== point) {
            this._calloutAnchorPoint = point;
            this.setState({
                refSelected: mouseEvent,
                /** Show the callout if highlighted bar is hovered and Hide it if unhighlighted bar is hovered */
                isCalloutVisible: this.state.selectedLegend === '' || this.state.selectedLegend === point.legend,
                calloutLegend: point.legend,
                dataForHoverCard: pointData,
                color: color,
                xCalloutValue: point.xAxisCalloutData,
                yCalloutValue: point.yAxisCalloutData,
                dataPointCalloutProps: point,
                callOutAccessibilityData: point.callOutAccessibilityData,
            });
        }
    };
    StackedBarChartBase.prototype._onBarLeave = function () {
        /**/
    };
    StackedBarChartBase.prototype._redirectToUrl = function (href) {
        href ? (window.location.href = href) : '';
    };
    StackedBarChartBase.defaultProps = {
        barHeight: 12,
        hideNumberDisplay: false,
        hideLegend: false,
        ignoreFixStyle: false,
    };
    return StackedBarChartBase;
}(React.Component));
export { StackedBarChartBase };
//# sourceMappingURL=StackedBarChart.base.js.map