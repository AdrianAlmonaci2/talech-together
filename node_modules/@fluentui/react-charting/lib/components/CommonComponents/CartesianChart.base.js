import { __assign, __extends } from "tslib";
import * as React from 'react';
import { classNamesFunction, getId, getRTL } from '@fluentui/react/lib/Utilities';
import { Callout } from '@fluentui/react/lib/Callout';
import { FocusZone, FocusZoneDirection } from '@fluentui/react-focus';
import { ChartHoverCard, convertToLocaleString, createNumericXAxis, createStringXAxis, getAccessibleDataObject, getDomainNRangeValues, createDateXAxis, createYAxis, createStringYAxis, getMinMaxOfYAxis, XAxisTypes, YAxisType, createWrapOfXLabels, rotateXAxisLabels, Points, pointTypes, } from '../../utilities/index';
import { Shape } from '../Legends/index';
var getClassNames = classNamesFunction();
/**
 * Cartesian chart used for
 * 1.draw X and Y axis of the chart
 * 2.Callout
 * 3.Fit parent Continer
 */
var CartesianChartBase = /** @class */ (function (_super) {
    __extends(CartesianChartBase, _super);
    function CartesianChartBase(props) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        var _this = _super.call(this, props) || this;
        _this.minLegendContainerHeight = 32;
        _this._isRtl = getRTL();
        // TO DO: Write a common functional component for Multi value callout and divide sub count method
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        _this._multiValueCallout = function (calloutProps) {
            var yValueHoverSubCountsExists = _this._yValueHoverSubCountsExists(calloutProps.YValueHover);
            return (React.createElement("div", { className: _this._classNames.calloutContentRoot },
                React.createElement("div", { className: _this._classNames.calloutDateTimeContainer, style: yValueHoverSubCountsExists ? { marginBottom: '11px' } : {} },
                    React.createElement("div", __assign({ className: _this._classNames.calloutContentX }, getAccessibleDataObject(calloutProps.xAxisCalloutAccessibilityData, 'text', false)), convertToLocaleString(calloutProps.hoverXValue, _this.props.culture))),
                React.createElement("div", { className: _this._classNames.calloutInfoContainer, style: yValueHoverSubCountsExists ? { display: 'flex' } : {} },
                    calloutProps.YValueHover &&
                        calloutProps.YValueHover.map(function (yValue, index, yValues) {
                            var isLast = index + 1 === yValues.length;
                            var _a = yValue.shouldDrawBorderBottom, shouldDrawBorderBottom = _a === void 0 ? false : _a;
                            return (React.createElement("div", __assign({}, getAccessibleDataObject(yValue.callOutAccessibilityData, 'text', false), { key: "callout-content-" + index, style: yValueHoverSubCountsExists
                                    ? __assign({ display: 'inline-block' }, (shouldDrawBorderBottom && {
                                        borderBottom: "1px solid " + _this.props.theme.semanticColors.menuDivider,
                                        paddingBottom: '10px',
                                    })) : __assign({}, (shouldDrawBorderBottom && {
                                    borderBottom: "1px solid " + _this.props.theme.semanticColors.menuDivider,
                                    paddingBottom: '10px',
                                })) }), _this._getCalloutContent(yValue, index, yValueHoverSubCountsExists, isLast)));
                        }),
                    !!calloutProps.descriptionMessage && (React.createElement("div", { className: _this._classNames.descriptionMessage }, calloutProps.descriptionMessage)))));
        };
        // Call back to the chart.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        _this._getData = function (xScale, yScale) {
            _this.props.getGraphData &&
                _this.props.getGraphData(xScale, yScale, _this.state.containerHeight - _this.state._removalValueForTextTuncate, _this.state.containerWidth, _this.xAxisElement);
        };
        _this.state = {
            containerHeight: 0,
            containerWidth: 0,
            _width: _this.props.width || 600,
            _height: _this.props.height || 350,
            _removalValueForTextTuncate: 0,
            isRemoveValCalculated: true,
        };
        _this.idForGraph = getId('chart_');
        /**
         * In RTL mode, Only graph will be rendered left/right. We need to provide left and right margins manually.
         * So that, in RTL, left margins becomes right margins and viceversa.
         * As graph needs to be drawn perfecty, these values consider as default values.
         * Same margins using for all other cartesian charts. Can be accessible through 'getMargins' call back method.
         */
        _this.margins = {
            top: (_b = (_a = _this.props.margins) === null || _a === void 0 ? void 0 : _a.top) !== null && _b !== void 0 ? _b : 20,
            bottom: (_d = (_c = _this.props.margins) === null || _c === void 0 ? void 0 : _c.bottom) !== null && _d !== void 0 ? _d : 35,
            right: _this._isRtl ? (_f = (_e = _this.props.margins) === null || _e === void 0 ? void 0 : _e.left) !== null && _f !== void 0 ? _f : 40 : (_h = (_g = _this.props.margins) === null || _g === void 0 ? void 0 : _g.right) !== null && _h !== void 0 ? _h : 20,
            left: _this._isRtl ? (_k = (_j = _this.props.margins) === null || _j === void 0 ? void 0 : _j.right) !== null && _k !== void 0 ? _k : 20 : (_m = (_l = _this.props.margins) === null || _l === void 0 ? void 0 : _l.left) !== null && _m !== void 0 ? _m : 40,
        };
        return _this;
    }
    CartesianChartBase.prototype.componentDidMount = function () {
        this._fitParentContainer();
    };
    CartesianChartBase.prototype.componentWillUnmount = function () {
        cancelAnimationFrame(this._reqID);
    };
    CartesianChartBase.prototype.componentDidUpdate = function (prevProps) {
        if (prevProps.height !== this.props.height || prevProps.width !== this.props.width) {
            this._fitParentContainer();
        }
        if (!this.props.wrapXAxisLables &&
            this.props.rotateXAxisLables &&
            this.props.xAxisType === XAxisTypes.StringAxis) {
            var rotateLabelProps = {
                node: this.xAxisElement,
                xAxis: this._xScale,
            };
            var rotatedHeight = rotateXAxisLabels(rotateLabelProps);
            if (this.state.isRemoveValCalculated &&
                this.state._removalValueForTextTuncate !== rotatedHeight + this.margins.bottom &&
                rotatedHeight > 0) {
                this.setState({
                    _removalValueForTextTuncate: rotatedHeight + this.margins.bottom,
                    isRemoveValCalculated: false,
                });
            }
        }
    };
    CartesianChartBase.prototype.render = function () {
        var _this = this;
        var _a = this.props, calloutProps = _a.calloutProps, points = _a.points, chartType = _a.chartType, chartHoverProps = _a.chartHoverProps, svgFocusZoneProps = _a.svgFocusZoneProps, svgProps = _a.svgProps, culture = _a.culture, dateLocalizeOptions = _a.dateLocalizeOptions, timeFormatLocale = _a.timeFormatLocale, customDateTimeFormatter = _a.customDateTimeFormatter;
        if (this.props.parentRef) {
            this._fitParentContainer();
        }
        // Callback for margins to the chart
        this.props.getmargins && this.props.getmargins(this.margins);
        var XAxisParams = {
            domainNRangeValues: getDomainNRangeValues(points, this.margins, this.state.containerWidth, chartType, this._isRtl, this.props.xAxisType, this.props.barwidth, this.props.tickValues),
            xAxisElement: this.xAxisElement,
            showRoundOffXTickValues: true,
            xAxisCount: this.props.xAxisTickCount,
            xAxistickSize: this.props.xAxistickSize,
            tickPadding: this.props.tickPadding || this.props.showXAxisLablesTooltip ? 5 : 10,
            xAxisPadding: this.props.xAxisPadding,
        };
        var YAxisParams = {
            margins: this.margins,
            containerWidth: this.state.containerWidth,
            containerHeight: this.state.containerHeight - this.state._removalValueForTextTuncate,
            yAxisElement: this.yAxisElement,
            yAxisTickFormat: this.props.yAxisTickFormat,
            yAxisTickCount: this.props.yAxisTickCount,
            yMinValue: this.props.yMinValue || 0,
            yMaxValue: this.props.yMaxValue || 0,
            tickPadding: 10,
            maxOfYVal: this.props.maxOfYVal,
            yMinMaxValues: getMinMaxOfYAxis(points, chartType),
            yAxisPadding: this.props.yAxisPadding,
        };
        /**
         * These scales used for 2 purposes.
         * 1. To create x and y axis
         * 2. To draw the graph.
         * For area/line chart using same scales. For other charts, creating their own scales to draw the graph.
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var xScale;
        switch (this.props.xAxisType) {
            case XAxisTypes.NumericAxis:
                xScale = createNumericXAxis(XAxisParams, culture);
                break;
            case XAxisTypes.DateAxis:
                xScale = createDateXAxis(XAxisParams, this.props.tickParams, culture, dateLocalizeOptions, timeFormatLocale, customDateTimeFormatter);
                break;
            case XAxisTypes.StringAxis:
                xScale = createStringXAxis(XAxisParams, this.props.tickParams, this.props.datasetForXAxisDomain, culture);
                break;
            default:
                xScale = createNumericXAxis(XAxisParams, culture);
        }
        this._xScale = xScale;
        /*
         * To enable wrapping of x axis tick values or to display complete x axis tick values,
         * we need to calculate how much space it needed to render the text.
         * No need to re-calculate every time the chart renders and same time need to get an update. So using setState.
         * Required space will be calculated first time chart rendering and if any width/height of chart updated.
         * */
        if (this.props.wrapXAxisLables || this.props.showXAxisLablesTooltip) {
            var wrapLabelProps = {
                node: this.xAxisElement,
                xAxis: xScale,
                showXAxisLablesTooltip: this.props.showXAxisLablesTooltip || false,
                noOfCharsToTruncate: this.props.noOfCharsToTruncate || 4,
            };
            var temp = xScale && createWrapOfXLabels(wrapLabelProps);
            // this value need to be updated for draw graph updated. So instead of using private value, using set state.
            if (this.state.isRemoveValCalculated && this.state._removalValueForTextTuncate !== temp) {
                this.setState({ _removalValueForTextTuncate: temp, isRemoveValCalculated: false });
            }
        }
        /**
         * These scales used for 2 purposes.
         * 1. To create x and y axis
         * 2. To draw the graph.
         * For area/line chart using same scales. For other charts, creating their own scales to draw the graph.
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var yScale;
        var axisData = { yAxisDomainValues: [] };
        if (this.props.yAxisType && this.props.yAxisType === YAxisType.StringAxis) {
            yScale = createStringYAxis(YAxisParams, this.props.stringDatasetForYAxisDomain, this._isRtl);
        }
        else {
            yScale = createYAxis(YAxisParams, this._isRtl, axisData);
        }
        this.props.getAxisData && this.props.getAxisData(axisData);
        // Callback function for chart, returns axis
        this._getData(xScale, yScale);
        this._classNames = getClassNames(this.props.styles, {
            theme: this.props.theme,
            width: this.state._width,
            height: this.state._height,
            className: this.props.className,
            isRtl: this._isRtl,
        });
        var svgDimensions = {
            width: this.state.containerWidth,
            height: this.state.containerHeight,
        };
        var children = this.props.children(__assign(__assign({}, this.state), { xScale: xScale, yScale: yScale }));
        var focusDirection;
        if (this.props.focusZoneDirection === FocusZoneDirection.vertical) {
            focusDirection = this.props.focusZoneDirection;
        }
        else if (this.props.focusZoneDirection) {
            focusDirection = this.props.focusZoneDirection;
        }
        else {
            focusDirection = FocusZoneDirection.horizontal;
        }
        return (React.createElement("div", { id: this.idForGraph, className: this._classNames.root, role: 'presentation', ref: function (rootElem) { return (_this.chartContainer = rootElem); }, onMouseLeave: this.props.onChartMouseLeave },
            React.createElement(FocusZone, __assign({ direction: focusDirection }, svgFocusZoneProps),
                React.createElement("svg", __assign({ width: svgDimensions.width, height: svgDimensions.height, "aria-label": this.props.chartTitle, style: { display: 'block' } }, svgProps),
                    React.createElement("g", { ref: function (e) {
                            _this.xAxisElement = e;
                        }, id: "xAxisGElement" + this.idForGraph, 
                        // To add wrap of x axis lables feature, need to remove word height from svg height.
                        transform: "translate(0, " + (svgDimensions.height - this.margins.bottom - this.state._removalValueForTextTuncate) + ")", className: this._classNames.xAxis }),
                    React.createElement("g", { ref: function (e) {
                            _this.yAxisElement = e;
                        }, id: "yAxisGElement" + this.idForGraph, transform: "translate(" + (this._isRtl ? svgDimensions.width - this.margins.right : this.margins.left) + ", 0)", className: this._classNames.yAxis }),
                    children)),
            !this.props.hideLegend && (React.createElement("div", { ref: function (e) { return (_this.legendContainer = e); }, className: this._classNames.legendContainer }, this.props.legendBars)),
            React.createElement(Callout, __assign({ hidden: !(!this.props.hideTooltip && calloutProps.isCalloutVisible), 
                /** Keep the callout updated with details of focused/hovered chart element */
                shouldUpdateWhenHidden: true }, calloutProps),
                this.props.customizedCallout && this.props.customizedCallout,
                !this.props.customizedCallout && this.props.isCalloutForStack && this._multiValueCallout(calloutProps),
                !this.props.customizedCallout && !this.props.isCalloutForStack && (React.createElement(ChartHoverCard, __assign({ XValue: calloutProps.XValue, Legend: calloutProps.legend, YValue: calloutProps.YValue, color: calloutProps.color, culture: this.props.culture }, chartHoverProps))))));
    };
    CartesianChartBase.prototype._yValueHoverSubCountsExists = function (yValueHover) {
        if (yValueHover) {
            return yValueHover.some(function (yValue) { return yValue.yAxisCalloutData && typeof yValue.yAxisCalloutData !== 'string'; });
        }
        return false;
    };
    CartesianChartBase.prototype._getCalloutContent = function (xValue, index, yValueHoverSubCountsExists, isLast) {
        var marginStyle = isLast ? {} : { marginRight: '16px' };
        var toDrawShape = xValue.index !== undefined && xValue.index !== -1;
        var _classNames = getClassNames(this.props.styles, {
            theme: this.props.theme,
            width: this.state._width,
            height: this.state._height,
            className: this.props.className,
            isRtl: this._isRtl,
            lineColor: xValue.color,
            toDrawShape: toDrawShape,
        });
        var culture = this.props.culture;
        var yValue = convertToLocaleString(xValue.y, culture);
        if (!xValue.yAxisCalloutData || typeof xValue.yAxisCalloutData === 'string') {
            return (React.createElement("div", { style: yValueHoverSubCountsExists ? marginStyle : {} },
                yValueHoverSubCountsExists && (React.createElement("div", { className: "ms-fontWeight-semibold", style: { fontSize: '12pt' } },
                    xValue.legend,
                    " (",
                    yValue,
                    ")")),
                React.createElement("div", { id: index + "_" + xValue.y, className: _classNames.calloutBlockContainer },
                    toDrawShape && (React.createElement(Shape, { svgProps: {
                            className: _classNames.shapeStyles,
                        }, pathProps: { fill: xValue.color }, shape: Points[xValue.index % Object.keys(pointTypes).length] })),
                    React.createElement("div", null,
                        React.createElement("div", { className: _classNames.calloutlegendText },
                            " ",
                            xValue.legend),
                        React.createElement("div", { className: _classNames.calloutContentY }, convertToLocaleString(xValue.yAxisCalloutData ? xValue.yAxisCalloutData : xValue.y || xValue.data, culture))))));
        }
        else {
            var subcounts_1 = xValue.yAxisCalloutData;
            return (React.createElement("div", { style: marginStyle },
                React.createElement("div", { className: "ms-fontWeight-semibold", style: { fontSize: '12pt' } },
                    xValue.legend,
                    " (",
                    yValue,
                    ")"),
                Object.keys(subcounts_1).map(function (subcountName) {
                    return (React.createElement("div", { key: subcountName, className: _classNames.calloutBlockContainer },
                        React.createElement("div", { className: _classNames.calloutlegendText },
                            " ",
                            convertToLocaleString(subcountName, culture)),
                        React.createElement("div", { className: _classNames.calloutContentY }, convertToLocaleString(subcounts_1[subcountName], culture))));
                })));
        }
    };
    /**
     * When screen resizes, along with screen, chart also auto adjusted.
     * This method used to adjust height and width of the charts.
     */
    CartesianChartBase.prototype._fitParentContainer = function () {
        var _this = this;
        var _a = this.state, containerWidth = _a.containerWidth, containerHeight = _a.containerHeight;
        this._reqID = requestAnimationFrame(function () {
            var legendContainerHeight;
            if (_this.props.hideLegend) {
                // If there is no legend, need not to allocate some space from total chart space.
                legendContainerHeight = 0;
            }
            else {
                var legendContainerComputedStyles = _this.legendContainer && getComputedStyle(_this.legendContainer);
                legendContainerHeight =
                    ((_this.legendContainer && _this.legendContainer.getBoundingClientRect().height) ||
                        _this.minLegendContainerHeight) +
                        parseFloat((legendContainerComputedStyles && legendContainerComputedStyles.marginTop) || '0') +
                        parseFloat((legendContainerComputedStyles && legendContainerComputedStyles.marginBottom) || '0');
            }
            if (_this.props.parentRef || _this.chartContainer) {
                var container = _this.props.parentRef ? _this.props.parentRef : _this.chartContainer;
                var currentContainerWidth = container.getBoundingClientRect().width;
                var currentContainerHeight = container.getBoundingClientRect().height > legendContainerHeight
                    ? container.getBoundingClientRect().height
                    : 350;
                var shouldResize = containerWidth !== currentContainerWidth ||
                    containerHeight !== currentContainerHeight - legendContainerHeight;
                if (shouldResize) {
                    _this.setState({
                        containerWidth: currentContainerWidth,
                        containerHeight: currentContainerHeight - legendContainerHeight,
                    });
                }
            }
        });
    };
    return CartesianChartBase;
}(React.Component));
export { CartesianChartBase };
//# sourceMappingURL=CartesianChart.base.js.map