import { __assign } from "tslib";
import * as React from 'react';
import { findIndex } from '@fluentui/react/lib/Utilities';
import { LabelLink } from './LabelLink';
export var EventsAnnotation = function (props) {
    var textWidth = props.labelWidth ? props.labelWidth : 105;
    var textY = props.chartYTop - 20;
    var lineTopY = textY + 7;
    var textPadding = 5;
    var lineHeight = 18;
    var fontSize = '10pt';
    var axisRange = props.scale.range();
    var lineDefs = props.events.map(function (e) { return (__assign(__assign({}, e), { x: props.scale(e.date) })); });
    lineDefs.sort(function (e1, e2) { return +e1.date - +e2.date; });
    var darkThemeMq = window.matchMedia('(prefers-color-scheme: dark)');
    var fill = darkThemeMq.matches ? 'rgb(255,255,255)' : props.strokeColor;
    var lines = uniqBy(lineDefs, function (x) { return x.date.toString(); }).map(function (x, i) { return (React.createElement("line", { key: i, x1: x.x, x2: x.x, y1: lineTopY, y2: props.chartYBottom, stroke: fill, strokeDasharray: "8" })); });
    var labelLinks = calculateLabels(lineDefs, textWidth + textPadding, axisRange[1], axisRange[0]).map(function (x, i) { return (React.createElement(LabelLink, __assign({ key: i }, {
        lineDefs: lineDefs,
        labelDef: x,
        textY: textY,
        textWidth: textWidth,
        textLineHeight: lineHeight,
        textFontSize: fontSize,
        textColor: props.labelColor,
        mergedLabel: props.mergedLabel,
    }))); });
    return (React.createElement(React.Fragment, null,
        lines,
        labelLinks));
};
function calculateLabels(lineDefs, textWidth, maxX, minX) {
    var calculateLabel = function (lastX, currentIdx) {
        // base case 1
        if (currentIdx === lineDefs.length) {
            return [];
        }
        var x = lineDefs[currentIdx].x;
        var leftXBoundary = x - textWidth;
        // cannot render on top of other text
        if (x < lastX) {
            return [];
        }
        // base case 2
        if (currentIdx === lineDefs.length - 1) {
            if (lastX < leftXBoundary) {
                return [{ x: x, anchor: 'end', aggregatedIdx: [currentIdx] }];
            }
            else if (x + textWidth < maxX) {
                return [{ x: x, anchor: 'start', aggregatedIdx: [currentIdx] }];
            }
            return [];
        }
        if (lastX < leftXBoundary) {
            // label on left side
            return backtrack(currentIdx, 'end');
        }
        else {
            // label on right side
            return backtrack(currentIdx, 'start');
        }
    };
    var backtrack = function (currentIdx, anchor) {
        var bd = anchor === 'end' ? lineDefs[currentIdx].x : lineDefs[currentIdx].x + textWidth;
        var idx = findIndex(lineDefs, function (ds) { return ds.x > bd && (ds.x - textWidth >= bd || ds.x + textWidth < maxX); }, currentIdx + 1);
        if (idx === -1) {
            idx = lineDefs.length;
        }
        var aggregatedIdx = [];
        for (var i = currentIdx; i < idx; i++) {
            aggregatedIdx.push(i);
        }
        var next = calculateLabel(bd, idx);
        next.unshift({ x: lineDefs[currentIdx].x, anchor: anchor, aggregatedIdx: aggregatedIdx });
        return next;
    };
    return calculateLabel(minX, 0);
}
/** Get unique items of `arr`, comparing based on the result of calling `iteratee` on each item. */
function uniqBy(arr, iteratee) {
    var seen = [];
    var result = [];
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var x = arr_1[_i];
        var comp = iteratee(x);
        if (seen.indexOf(comp) === -1) {
            result.push(x);
            seen.push(comp);
        }
    }
    return result;
}
//# sourceMappingURL=EventAnnotation.js.map