import { __assign, __extends } from "tslib";
import * as React from 'react';
import { classNamesFunction, find, getId } from '@fluentui/react/lib/Utilities';
import { Callout, DirectionalHint } from '@fluentui/react/lib/Callout';
import { ChartHoverCard, convertToLocaleString, getAccessibleDataObject } from '../../utilities/index';
import { FocusZone, FocusZoneDirection } from '@fluentui/react-focus';
import { TooltipHost, TooltipOverflowMode } from '@fluentui/react';
var getClassNames = classNamesFunction();
var HorizontalBarChartBase = /** @class */ (function (_super) {
    __extends(HorizontalBarChartBase, _super);
    function HorizontalBarChartBase(props) {
        var _this = _super.call(this, props) || this;
        _this._handleChartMouseLeave = function () {
            _this._calloutAnchorPoint = null;
            if (_this.state.isCalloutVisible) {
                _this.setState({
                    isCalloutVisible: false,
                    hoverValue: '',
                    refSelected: null,
                    lineColor: '',
                    legend: '',
                });
            }
        };
        _this._adjustProps = function () {
            _this._barHeight = _this.props.barHeight || 12;
            _this._classNames = getClassNames(_this.props.styles, {
                theme: _this.props.theme,
                width: _this.props.width,
                className: _this.props.className,
                barHeight: _this._barHeight,
                color: _this.state.lineColor,
            });
        };
        _this._getChartDataText = function (data) {
            return _this.props.barChartCustomData ? (React.createElement("div", { "data-is-focusable": true, role: "text" }, _this.props.barChartCustomData(data))) : (_this._getDefaultTextData(data));
        };
        _this._closeCallout = function () {
            _this.setState({
                isCalloutVisible: false,
            });
        };
        _this._getAriaLabel = function (point) {
            var _a;
            var legend = point.xAxisCalloutData || point.legend;
            var yValue = point.yAxisCalloutData ||
                (point.horizontalBarChartdata ? point.horizontalBarChartdata.x + "/" + point.horizontalBarChartdata.y : 0);
            return ((_a = point.callOutAccessibilityData) === null || _a === void 0 ? void 0 : _a.ariaLabel) || (legend ? legend + ", " : '') + (yValue + ".");
        };
        _this.state = {
            isCalloutVisible: false,
            hoverValue: '',
            lineColor: '',
            legend: '',
            refSelected: null,
            // eslint-disable-next-line react/no-unused-state
            color: '',
            xCalloutValue: '',
            yCalloutValue: '',
        };
        _this._refArray = [];
        _this._uniqLineText = '_HorizontalLine_' + Math.random().toString(36).substring(7);
        _this._hoverOff = _this._hoverOff.bind(_this);
        _this._calloutId = getId('callout');
        return _this;
    }
    HorizontalBarChartBase.prototype.render = function () {
        var _this = this;
        var _a = this.props, data = _a.data, theme = _a.theme;
        this._adjustProps();
        var palette = theme.palette;
        var datapoint = 0;
        return (React.createElement("div", { className: this._classNames.root, onMouseLeave: this._handleChartMouseLeave },
            data.map(function (points, index) {
                if (points.chartData && points.chartData[0] && points.chartData[0].horizontalBarChartdata.x) {
                    datapoint = points.chartData[0].horizontalBarChartdata.x;
                }
                else {
                    datapoint = 0;
                }
                points.chartData[1] = {
                    legend: '',
                    horizontalBarChartdata: {
                        x: points.chartData[0].horizontalBarChartdata.y - datapoint,
                        y: points.chartData[0].horizontalBarChartdata.y,
                    },
                    color: palette.neutralLight,
                };
                var chartDataText = _this._getChartDataText(points);
                var bars = _this._createBars(points, palette);
                var keyVal = _this._uniqLineText + '_' + index;
                var classNames = getClassNames(_this.props.styles, {
                    theme: _this.props.theme,
                    width: _this.props.width,
                    showTriangle: !!points.chartData[0].data,
                });
                return (React.createElement("div", { key: index },
                    React.createElement("div", { className: classNames.items },
                        React.createElement(FocusZone, { direction: FocusZoneDirection.horizontal },
                            React.createElement("div", { className: _this._classNames.chartTitle },
                                points.chartTitle && (React.createElement(TooltipHost, { overflowMode: TooltipOverflowMode.Self, hostClassName: _this._classNames.chartTitleLeft, content: points.chartTitle },
                                    React.createElement("span", __assign({}, getAccessibleDataObject(points.chartTitleAccessibilityData)), points.chartTitle))),
                                chartDataText)),
                        points.chartData[0].data && _this._createBenchmark(points),
                        React.createElement(FocusZone, { direction: FocusZoneDirection.horizontal },
                            React.createElement("svg", { className: _this._classNames.chart, "aria-label": points.chartTitle },
                                React.createElement("g", { id: keyVal, key: keyVal, ref: function (e) {
                                        _this._refCallback(e, points.chartData[0].legend);
                                    }, 
                                    // NOTE: points.chartData![0] contains current data value
                                    onClick: function () {
                                        var p = points.chartData[0];
                                        if (p && p.onClick) {
                                            p.onClick();
                                        }
                                    }, className: _this._classNames.barWrapper }, bars))))));
            }),
            React.createElement(Callout, __assign({ target: this.state.refSelected, coverTarget: true, isBeakVisible: false, gapSpace: 30, hidden: !(!this.props.hideTooltip && this.state.isCalloutVisible), directionalHint: DirectionalHint.topAutoEdge, id: this._calloutId, onDismiss: this._closeCallout, preventDismissOnLostFocus: true }, this.props.calloutProps, getAccessibleDataObject(this.state.callOutAccessibilityData)),
                React.createElement(React.Fragment, null, this.props.onRenderCalloutPerHorizontalBar ? (this.props.onRenderCalloutPerHorizontalBar(this.state.barCalloutProps)) : (React.createElement(ChartHoverCard, { Legend: this.state.xCalloutValue ? this.state.xCalloutValue : this.state.legend, YValue: this.state.yCalloutValue ? this.state.yCalloutValue : this.state.hoverValue, color: this.state.lineColor, culture: this.props.culture }))))));
    };
    HorizontalBarChartBase.prototype._refCallback = function (element, legendTitle) {
        this._refArray.push({ index: legendTitle, refElement: element });
    };
    HorizontalBarChartBase.prototype._hoverOn = function (hoverValue, point) {
        if ((!this.state.isCalloutVisible || this.state.legend !== point.legend) && this._calloutAnchorPoint !== point) {
            var currentHoveredElement = find(this._refArray, function (currentElement) { return currentElement.index === point.legend; });
            this._calloutAnchorPoint = point;
            this.setState({
                isCalloutVisible: true,
                hoverValue: hoverValue,
                lineColor: point.color,
                legend: point.legend,
                refSelected: currentHoveredElement.refElement,
                xCalloutValue: point.xAxisCalloutData,
                yCalloutValue: point.yAxisCalloutData,
                barCalloutProps: point,
                callOutAccessibilityData: point.callOutAccessibilityData,
            });
        }
    };
    HorizontalBarChartBase.prototype._hoverOff = function () {
        /**/
    };
    HorizontalBarChartBase.prototype._getDefaultTextData = function (data) {
        var culture = this.props.culture;
        var chartDataMode = this.props.chartDataMode || 'default';
        var chartData = data.chartData[0];
        var x = chartData.horizontalBarChartdata.x;
        var y = chartData.horizontalBarChartdata.y;
        var accessibilityData = getAccessibleDataObject(data.chartDataAccessibilityData);
        switch (chartDataMode) {
            case 'default':
                return (React.createElement("div", __assign({ className: this._classNames.chartTitleRight }, accessibilityData), convertToLocaleString(x, culture)));
            case 'fraction':
                return (React.createElement("div", __assign({}, accessibilityData),
                    React.createElement("span", { className: this._classNames.chartTitleRight }, convertToLocaleString(x, culture)),
                    React.createElement("span", { className: this._classNames.chartDataTextDenominator }, ' / ' + convertToLocaleString(y, culture))));
            case 'percentage':
                var dataRatioPercentage = convertToLocaleString(Math.round((x / y) * 100), culture) + "%";
                return (React.createElement("div", __assign({ className: this._classNames.chartTitleRight }, accessibilityData), dataRatioPercentage));
        }
    };
    HorizontalBarChartBase.prototype._createBenchmark = function (data) {
        var totalData = data.chartData[0].horizontalBarChartdata.y;
        var benchmarkData = data.chartData[0].data;
        var benchmarkRatio = Math.round(((benchmarkData ? benchmarkData : 0) / totalData) * 100);
        var benchmarkStyles = {
            left: 'calc(' + benchmarkRatio + '% - 4px)',
        };
        return (React.createElement("div", { className: this._classNames.benchmarkContainer },
            React.createElement("div", { className: this._classNames.triangle, style: benchmarkStyles })));
    };
    HorizontalBarChartBase.prototype._createBars = function (data, palette) {
        var _this = this;
        var defaultPalette = [palette.blueLight, palette.blue, palette.blueMid, palette.red, palette.black];
        // calculating starting point of each bar and it's range
        var startingPoint = [];
        var total = data.chartData.reduce(function (acc, point) {
            return acc + (point.horizontalBarChartdata.x ? point.horizontalBarChartdata.x : 0);
        }, 0);
        var prevPosition = 0;
        var value = 0;
        var sumOfPercent = 0;
        data.chartData.map(function (point, index) {
            var pointData = point.horizontalBarChartdata.x ? point.horizontalBarChartdata.x : 0;
            value = (pointData / total) * 100;
            if (value < 0) {
                value = 0;
            }
            else if (value < 1 && value !== 0) {
                value = 1;
            }
            sumOfPercent += value;
            return sumOfPercent;
        });
        var scalingRatio = sumOfPercent !== 0 ? sumOfPercent / 100 : 1;
        var bars = data.chartData.map(function (point, index) {
            var color = point.color ? point.color : defaultPalette[Math.floor(Math.random() * 4 + 1)];
            var pointData = point.horizontalBarChartdata.x ? point.horizontalBarChartdata.x : 0;
            if (index > 0) {
                prevPosition += value;
            }
            value = (pointData / total) * 100;
            if (value < 0) {
                value = 0;
            }
            else if (value < 1 && value !== 0) {
                value = 1 / scalingRatio;
            }
            else {
                value = value / scalingRatio;
            }
            startingPoint.push(prevPosition);
            var xValue = point.horizontalBarChartdata.x;
            return (React.createElement("rect", { key: index, x: startingPoint[index] + '%', y: 0, "data-is-focusable": point.legend !== '' ? true : false, width: value + '%', height: _this._barHeight, fill: color, onMouseOver: point.legend !== '' ? _this._hoverOn.bind(_this, xValue, point) : undefined, onFocus: point.legend !== '' ? _this._hoverOn.bind(_this, xValue, point) : undefined, role: "img", "aria-label": _this._getAriaLabel(point), onBlur: _this._hoverOff, onMouseLeave: _this._hoverOff }));
        });
        return bars;
    };
    return HorizontalBarChartBase;
}(React.Component));
export { HorizontalBarChartBase };
//# sourceMappingURL=HorizontalBarChart.base.js.map