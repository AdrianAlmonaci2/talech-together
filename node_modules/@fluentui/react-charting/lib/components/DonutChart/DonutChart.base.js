import { __assign, __extends } from "tslib";
import * as React from 'react';
import { classNamesFunction, getId } from '@fluentui/react/lib/Utilities';
import { Callout, DirectionalHint } from '@fluentui/react/lib/Callout';
import { FocusZone, FocusZoneDirection, FocusZoneTabbableElements } from '@fluentui/react-focus';
import { ChartHoverCard, Legends } from '../../index';
import { Pie } from './Pie/index';
import { convertToLocaleString, getAccessibleDataObject } from '../../utilities/index';
var getClassNames = classNamesFunction();
var DonutChartBase = /** @class */ (function (_super) {
    __extends(DonutChartBase, _super);
    function DonutChartBase(props) {
        var _this = _super.call(this, props) || this;
        _this._closeCallout = function () {
            _this.setState({
                showHover: false,
            });
        };
        _this._focusCallback = function (data, id, element) {
            _this._currentHoverElement = element;
            _this.setState({
                /** Show the callout if highlighted arc is focused and Hide it if unhighlighted arc is focused */
                showHover: _this.state.selectedLegend === '' || _this.state.selectedLegend === data.legend,
                value: data.data.toString(),
                legend: data.legend,
                color: data.color,
                xCalloutValue: data.xAxisCalloutData,
                yCalloutValue: data.yAxisCalloutData,
                focusedArcId: id,
                dataPointCalloutProps: data,
                callOutAccessibilityData: data.callOutAccessibilityData,
            });
        };
        _this._hoverCallback = function (data, e) {
            if (_this._calloutAnchorPoint !== data) {
                _this._calloutAnchorPoint = data;
                _this._currentHoverElement = e;
                _this.setState({
                    /** Show the callout if highlighted arc is hovered and Hide it if unhighlighted arc is hovered */
                    showHover: _this.state.selectedLegend === '' || _this.state.selectedLegend === data.legend,
                    value: data.data.toString(),
                    legend: data.legend,
                    color: data.color,
                    xCalloutValue: data.xAxisCalloutData,
                    yCalloutValue: data.yAxisCalloutData,
                    dataPointCalloutProps: data,
                    callOutAccessibilityData: data.callOutAccessibilityData,
                });
            }
        };
        _this._onBlur = function () {
            _this.setState({ focusedArcId: '' });
        };
        _this._handleChartMouseLeave = function () {
            _this._calloutAnchorPoint = null;
            _this.setState({ showHover: false });
        };
        _this.state = {
            showHover: false,
            value: '',
            legend: '',
            _width: _this.props.width || 200,
            _height: _this.props.height || 200,
            activeLegend: '',
            color: '',
            xCalloutValue: '',
            yCalloutValue: '',
            selectedLegend: '',
            focusedArcId: '',
        };
        _this._hoverCallback = _this._hoverCallback.bind(_this);
        _this._focusCallback = _this._focusCallback.bind(_this);
        _this._hoverLeave = _this._hoverLeave.bind(_this);
        _this._calloutId = getId('callout');
        _this._uniqText = getId('_Pie_');
        return _this;
    }
    DonutChartBase.getDerivedStateFromProps = function (nextProps, prevState) {
        if (nextProps.height && nextProps.height !== prevState._height && nextProps.width !== prevState._width) {
            var reducedHeight = nextProps.height / 5;
            return { _width: nextProps.width, _height: nextProps.height - reducedHeight };
        }
        return null;
    };
    DonutChartBase.prototype.componentDidMount = function () {
        /* 80% Height to the Chart
           20% Height to the Legends
        */
        var reducedHeight = this._rootElem && this._rootElem.offsetHeight / 5;
        this.setState({
            _width: (this._rootElem && this._rootElem.offsetWidth),
            _height: (this._rootElem && this._rootElem.offsetHeight - reducedHeight),
        });
    };
    DonutChartBase.prototype.render = function () {
        var _this = this;
        var _a;
        var _b = this.props, data = _b.data, _c = _b.hideLegend, hideLegend = _c === void 0 ? false : _c;
        var palette = this.props.theme.palette;
        this._classNames = getClassNames(this.props.styles, {
            theme: this.props.theme,
            width: this.state._width,
            height: this.state._height,
            color: this.state.color,
            className: this.props.className,
        });
        var legendBars = this._createLegends(data, palette);
        var outerRadius = Math.min(this.state._width, this.state._height) / 2;
        var chartData = data && ((_a = data.chartData) === null || _a === void 0 ? void 0 : _a.filter(function (d) { return d.data > 0; }));
        var valueInsideDonut = this._valueInsideDonut(this.props.valueInsideDonut, chartData);
        return (React.createElement("div", { className: this._classNames.root, ref: function (rootElem) { return (_this._rootElem = rootElem); }, onMouseLeave: this._handleChartMouseLeave },
            React.createElement(FocusZone, { direction: FocusZoneDirection.horizontal, handleTabKey: FocusZoneTabbableElements.all },
                React.createElement("div", null,
                    React.createElement("svg", { className: this._classNames.chart, "aria-label": data === null || data === void 0 ? void 0 : data.chartTitle, ref: function (node) { return _this._setViewBox(node); } },
                        React.createElement(Pie, { width: this.state._width, height: this.state._height, outerRadius: outerRadius, innerRadius: this.props.innerRadius, data: chartData, onFocusCallback: this._focusCallback, hoverOnCallback: this._hoverCallback, hoverLeaveCallback: this._hoverLeave, uniqText: this._uniqText, onBlurCallback: this._onBlur, activeArc: this._getHighlightedLegend(), focusedArcId: this.state.focusedArcId || '', href: this.props.href, calloutId: this._calloutId, valueInsideDonut: this._toLocaleString(valueInsideDonut), theme: this.props.theme })))),
            React.createElement(Callout, __assign({ target: this._currentHoverElement, alignTargetEdge: true, isBeakVisible: false, directionalHint: DirectionalHint.topAutoEdge, gapSpace: 15, hidden: !(!this.props.hideTooltip && this.state.showHover), id: this._calloutId, onDismiss: this._closeCallout, preventDismissOnLostFocus: true, 
                /** Keep the callout updated with details of focused/hovered arc */
                shouldUpdateWhenHidden: true }, this.props.calloutProps, getAccessibleDataObject(this.state.callOutAccessibilityData, 'text', false)), this.props.onRenderCalloutPerDataPoint ? (this.props.onRenderCalloutPerDataPoint(this.state.dataPointCalloutProps)) : (React.createElement(ChartHoverCard, { Legend: this.state.xCalloutValue ? this.state.xCalloutValue : this.state.legend, YValue: this.state.yCalloutValue ? this.state.yCalloutValue : this.state.value, color: this.state.color, culture: this.props.culture }))),
            !hideLegend && React.createElement("div", { className: this._classNames.legendContainer }, legendBars)));
    };
    DonutChartBase.prototype._setViewBox = function (node) {
        var _a, _b;
        if (node === null) {
            return;
        }
        var widthVal = node.parentElement ? node.parentElement.clientWidth : this.state._width;
        var heightVal = node.parentElement && ((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.offsetHeight) > this.state._height
            ? (_b = node.parentElement) === null || _b === void 0 ? void 0 : _b.offsetHeight
            : this.state._height;
        var viewbox = "0 0 " + widthVal + " " + heightVal;
        node.setAttribute('viewBox', viewbox);
    };
    DonutChartBase.prototype._createLegends = function (data, palette) {
        var _this = this;
        var defaultPalette = [palette.blueLight, palette.blue, palette.blueMid, palette.red, palette.black];
        var legendDataItems = data &&
            data.chartData.map(function (point, index) {
                var color = point.color ? point.color : defaultPalette[Math.floor(Math.random() * 4 + 1)];
                // mapping data to the format Legends component needs
                var legend = {
                    title: point.legend,
                    color: color,
                    action: function () {
                        if (_this.state.selectedLegend === point.legend) {
                            _this.setState({ selectedLegend: '' });
                        }
                        else {
                            _this.setState({ selectedLegend: point.legend });
                        }
                    },
                    hoverAction: function () {
                        _this._handleChartMouseLeave();
                        _this.setState({ activeLegend: point.legend });
                    },
                    onMouseOutAction: function () {
                        _this.setState({ activeLegend: '' });
                    },
                };
                return legend;
            });
        var legends = (React.createElement(Legends, __assign({ legends: legendDataItems, centerLegends: true, overflowProps: this.props.legendsOverflowProps, focusZonePropsInHoverCard: this.props.focusZonePropsForLegendsInHoverCard, overflowText: this.props.legendsOverflowText }, this.props.legendProps)));
        return legends;
    };
    DonutChartBase.prototype._hoverLeave = function () {
        /**/
    };
    DonutChartBase.prototype._valueInsideDonut = function (valueInsideDonut, data) {
        var highlightedLegend = this._getHighlightedLegend();
        if (valueInsideDonut !== undefined && highlightedLegend !== '' && !this.state.showHover) {
            var legendValue_1 = valueInsideDonut;
            data.map(function (point, index) {
                if (point.legend === highlightedLegend) {
                    legendValue_1 = point.yAxisCalloutData ? point.yAxisCalloutData : point.data;
                }
                return;
            });
            return legendValue_1;
        }
        else {
            return valueInsideDonut;
        }
    };
    DonutChartBase.prototype._toLocaleString = function (data) {
        var localeString = convertToLocaleString(data, this.props.culture);
        if (!localeString) {
            return data;
        }
        return localeString === null || localeString === void 0 ? void 0 : localeString.toString();
    };
    /**
     * This function returns
     * the selected legend if there is one
     * or the hovered legend if none of the legends is selected.
     * Note: This won't work in case of multiple legends selection.
     */
    DonutChartBase.prototype._getHighlightedLegend = function () {
        return this.state.selectedLegend || this.state.activeLegend;
    };
    DonutChartBase.defaultProps = {
        innerRadius: 0,
    };
    return DonutChartBase;
}(React.Component));
export { DonutChartBase };
//# sourceMappingURL=DonutChart.base.js.map