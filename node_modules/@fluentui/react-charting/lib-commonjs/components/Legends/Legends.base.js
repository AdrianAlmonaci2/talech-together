"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LegendsBase = void 0;
var tslib_1 = require("tslib");
var React = require("react");
var HoverCard_1 = require("@fluentui/react/lib/HoverCard");
var Utilities_1 = require("@fluentui/react/lib/Utilities");
var ResizeGroup_1 = require("@fluentui/react/lib/ResizeGroup");
var OverflowSet_1 = require("@fluentui/react/lib/OverflowSet");
var react_focus_1 = require("@fluentui/react-focus");
var shape_1 = require("./shape");
var utilities_1 = require("../../utilities/utilities");
var getClassNames = Utilities_1.classNamesFunction();
var LegendsBase = /** @class */ (function (_super) {
    tslib_1.__extends(LegendsBase, _super);
    function LegendsBase(props) {
        var _this = _super.call(this, props) || this;
        _this._onRenderData = function (data) {
            var _a = _this.props, overflowProps = _a.overflowProps, _b = _a.allowFocusOnLegends, allowFocusOnLegends = _b === void 0 ? true : _b;
            var rootStyles = {
                root: {
                    justifyContent: _this.props.centerLegends ? 'center' : 'unset',
                    flexWrap: 'wrap',
                },
            };
            return (React.createElement(react_focus_1.FocusZone, tslib_1.__assign({}, (allowFocusOnLegends && { role: 'listbox', 'aria-label': 'Legends' })),
                React.createElement(OverflowSet_1.OverflowSet, tslib_1.__assign({ items: data.primary, overflowItems: data.overflow, onRenderItem: _this._renderButton, onRenderOverflowButton: _this._renderOverflowItems }, overflowProps, { styles: tslib_1.__assign(tslib_1.__assign({}, rootStyles), overflowProps === null || overflowProps === void 0 ? void 0 : overflowProps.styles) }))));
        };
        _this._onReduceData = function (currentdata) {
            if (currentdata.primary.length === 0) {
                return;
            }
            var overflow = tslib_1.__spreadArray(tslib_1.__spreadArray([], currentdata.primary.slice(-1)), currentdata.overflow);
            var primary = currentdata.primary.slice(0, -1);
            return { primary: primary, overflow: overflow };
        };
        _this._onGrowData = function (currentdata) {
            if (currentdata.overflow.length === 0) {
                return;
            }
            var overflow = currentdata.overflow.slice(1);
            var primary = tslib_1.__spreadArray(tslib_1.__spreadArray([], currentdata.primary), currentdata.overflow.slice(0, 1));
            return { primary: primary, overflow: overflow };
        };
        /**
         * This function will get called when there is an ability to
         * select  multiple legends
         * @param legend ILegend
         */
        _this._canSelectMultipleLegends = function (legend) {
            var selectedLegends = utilities_1.silceOrAppendToArray(_this.state.selectedLegends, legend.title);
            _this.setState({
                //check if user selected all legends then empty it get the default behaviour
                selectedLegends: selectedLegends.length === _this.props.legends.length ? [] : selectedLegends,
            });
        };
        /**
         * This function will get called when there is
         * ability to select only single legend
         * @param legend ILegend
         */
        _this._canSelectOnlySingleLegend = function (legend) {
            if (_this.state.selectedLegend === legend.title) {
                _this.setState({
                    selectedLegend: '',
                });
            }
            else {
                _this.setState({
                    selectedLegend: legend.title,
                });
            }
        };
        _this._onClick = function (legend) {
            if (legend.action) {
                var _a = _this.props.canSelectMultipleLegends, canSelectMultipleLegends = _a === void 0 ? false : _a;
                if (canSelectMultipleLegends) {
                    _this._canSelectMultipleLegends(legend);
                }
                else {
                    _this._canSelectOnlySingleLegend(legend);
                }
                legend.action();
            }
        };
        _this._onRenderCompactCard = function (expandingCard) {
            var _a = _this.props, _b = _a.allowFocusOnLegends, allowFocusOnLegends = _b === void 0 ? true : _b, className = _a.className, styles = _a.styles, theme = _a.theme;
            var overflowHoverCardLegends = [];
            var classNames = getClassNames(styles, {
                theme: theme,
                className: className,
            });
            expandingCard.renderData.forEach(function (legend, index) {
                var hoverCardElement = _this._renderButton(legend, index, true);
                overflowHoverCardLegends.push(hoverCardElement);
            });
            var hoverCardData = (React.createElement(react_focus_1.FocusZone, tslib_1.__assign({}, (allowFocusOnLegends && { role: 'listbox' }), { direction: react_focus_1.FocusZoneDirection.vertical }, _this.props.focusZonePropsInHoverCard, { className: classNames.hoverCardRoot }), overflowHoverCardLegends));
            return hoverCardData;
        };
        _this._renderOverflowItems = function (legends) {
            var _a = _this.props.allowFocusOnLegends, allowFocusOnLegends = _a === void 0 ? true : _a;
            var items = [];
            legends.forEach(function (legend, i) {
                items.push({ key: i.toString(), name: legend.title, onClick: legend.action });
            });
            var renderOverflowData = { renderData: legends };
            var _b = _this.props, theme = _b.theme, className = _b.className, styles = _b.styles, overflowText = _b.overflowText;
            var classNames = getClassNames(styles, {
                theme: theme,
                className: className,
            });
            var plainCardProps = {
                onRenderPlainCard: _this._onRenderCompactCard,
                renderData: renderOverflowData,
            };
            var overflowString = overflowText ? overflowText : 'more';
            // execute similar to "_onClick" and "_onLeave" logic at HoverCard onCardHide event
            var onHoverCardHideHandler = function () {
                _this.setState({ isHoverCardVisible: false });
                /** Unhighlight the focused legend in the hover card */
                var activeOverflowItem = Utilities_1.find(legends, function (legend) { return legend.title === _this.state.activeLegend; });
                if (activeOverflowItem) {
                    _this.setState({ activeLegend: '' });
                    if (activeOverflowItem.onMouseOutAction) {
                        activeOverflowItem.onMouseOutAction();
                    }
                }
            };
            return (React.createElement(HoverCard_1.HoverCard, { type: HoverCard_1.HoverCardType.plain, plainCardProps: plainCardProps, instantOpenOnClick: true, 
                // eslint-disable-next-line react/jsx-no-bind
                onCardHide: onHoverCardHideHandler, setInitialFocus: true, trapFocus: true, onCardVisible: _this._hoverCardVisible, styles: classNames.subComponentStyles.hoverCardStyles, cardDismissDelay: 300, target: _this._hoverCardRef },
                React.createElement("div", tslib_1.__assign({ className: classNames.overflowIndicationTextStyle, ref: function (rootElem) { return (_this._hoverCardRef = rootElem); } }, (allowFocusOnLegends && {
                    role: 'button',
                    'aria-expanded': _this.state.isHoverCardVisible,
                    'aria-label': items.length + " " + overflowString,
                }), { "data-is-focusable": allowFocusOnLegends }),
                    items.length,
                    " ",
                    overflowString)));
        };
        _this._hoverCardVisible = function () {
            _this.setState({ isHoverCardVisible: true });
        };
        _this._onHoverOverLegend = function (legend) {
            if (legend.hoverAction) {
                _this.setState({ activeLegend: legend.title });
                legend.hoverAction();
            }
        };
        _this._onLeave = function (legend) {
            if (legend.onMouseOutAction) {
                _this.setState({ activeLegend: '' });
                legend.onMouseOutAction();
            }
        };
        _this._renderButton = function (data, index, overflow) {
            var _a = _this.props.allowFocusOnLegends, allowFocusOnLegends = _a === void 0 ? true : _a;
            var legend = {
                title: data.title,
                color: data.color,
                shape: data.shape,
                action: data.action,
                hoverAction: data.hoverAction,
                onMouseOutAction: data.onMouseOutAction,
                stripePattern: data.stripePattern,
                isLineLegendInBarChart: data.isLineLegendInBarChart,
                opacity: data.opacity,
            };
            var color = _this._getColor(legend.title, legend.color);
            var _b = _this.props, theme = _b.theme, className = _b.className, styles = _b.styles;
            var classNames = getClassNames(styles, {
                theme: theme,
                className: className,
                colorOnSelectedState: color,
                borderColor: legend.color,
                overflow: overflow,
                stripePattern: legend.stripePattern,
                isLineLegendInBarChart: legend.isLineLegendInBarChart,
                opacity: legend.opacity,
            });
            var onClickHandler = function () {
                _this._onClick(legend);
            };
            var onHoverHandler = function () {
                _this._onHoverOverLegend(legend);
            };
            var onMouseOut = function () {
                _this._onLeave(legend);
            };
            var shape = _this._getShape(classNames, legend, color);
            return (React.createElement("button", tslib_1.__assign({}, (allowFocusOnLegends && {
                'aria-selected': _this.state.selectedLegend === legend.title,
                role: 'option',
                'aria-label': legend.title + " selected",
                'aria-setsize': data['aria-setsize'],
                'aria-posinset': data['aria-posinset'],
            }), (data.nativeButtonProps && tslib_1.__assign({}, data.nativeButtonProps)), { key: index, className: classNames.legend, onClick: onClickHandler, onMouseOver: onHoverHandler, onMouseOut: onMouseOut, onFocus: onHoverHandler, onBlur: onMouseOut, "data-is-focusable": allowFocusOnLegends }),
                shape,
                React.createElement("div", { className: classNames.text }, legend.title)));
        };
        _this.state = {
            selectedLegend: '',
            activeLegend: '',
            isHoverCardVisible: false,
            selectedLegends: [],
        };
        return _this;
    }
    LegendsBase.prototype.render = function () {
        var _a = this.props, theme = _a.theme, className = _a.className, styles = _a.styles;
        this._classNames = getClassNames(styles, {
            theme: theme,
            className: className,
        });
        var dataToRender = this._generateData();
        return (React.createElement("div", { className: this._classNames.root }, this.props.enabledWrapLines ? (this._onRenderData(dataToRender)) : (React.createElement(ResizeGroup_1.ResizeGroup, { data: dataToRender, onReduceData: this._onReduceData, onRenderData: this._onRenderData, onGrowData: this._onGrowData }))));
    };
    LegendsBase.prototype._generateData = function () {
        var _this = this;
        var _a = this.props.allowFocusOnLegends, allowFocusOnLegends = _a === void 0 ? true : _a;
        var dataItems = this.props.legends.map(function (legend, index) {
            return tslib_1.__assign(tslib_1.__assign({}, (allowFocusOnLegends && {
                nativeButtonProps: Utilities_1.getNativeProps(legend, Utilities_1.buttonProperties, [
                    'title',
                ]),
                'aria-setsize': _this.props.legends.length,
                'aria-posinset': index + 1,
            })), { title: legend.title, action: legend.action, hoverAction: legend.hoverAction, onMouseOutAction: legend.onMouseOutAction, color: legend.color, shape: legend.shape, stripePattern: legend.stripePattern, isLineLegendInBarChart: legend.isLineLegendInBarChart, opacity: legend.opacity, key: index });
        });
        var result = {
            primary: dataItems,
            overflow: [],
        };
        return result;
    };
    LegendsBase.prototype._getShape = function (classNames, legend, color) {
        var svgParentProps = {
            className: classNames.shape,
        };
        var svgChildProps = {
            fill: color,
            strokeWidth: 2,
            stroke: legend.color,
        };
        return (React.createElement(shape_1.Shape, { svgProps: svgParentProps, pathProps: svgChildProps, shape: legend.shape, classNameForNonSvg: classNames.rect }));
    };
    LegendsBase.prototype._getColor = function (title, color) {
        var theme = this.props.theme;
        var palette = theme.palette;
        var legendColor = color;
        var inSelectedState = this.state.selectedLegend !== '' || this.state.selectedLegends.length > 0;
        if (inSelectedState) {
            /** if one or more legends are selected */
            if (this.state.selectedLegend === title || this.state.selectedLegends.indexOf(title) > -1) {
                /** if the given legend (title) is one of the selected legends */
                legendColor = color;
            }
            else {
                /** if the given legend is unselected */
                legendColor = palette.white;
            }
        }
        else {
            /** if no legend is selected */
            if (this.state.activeLegend === title || this.state.activeLegend === '') {
                /**
                 * if the given legend is hovered
                 * or none of the legends is hovered
                 */
                legendColor = color;
            }
            else {
                /** if there is a hovered legend but the given legend is not the one */
                legendColor = palette.white;
            }
        }
        return legendColor;
    };
    return LegendsBase;
}(React.Component));
exports.LegendsBase = LegendsBase;
//# sourceMappingURL=Legends.base.js.map