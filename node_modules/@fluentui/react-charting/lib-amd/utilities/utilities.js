define(["require", "exports", "tslib", "d3-axis", "d3-array", "d3-scale", "d3-selection", "d3-format", "d3-time-format", "d3-time"], function (require, exports, tslib_1, d3_axis_1, d3_array_1, d3_scale_1, d3_selection_1, d3_format_1, d3TimeFormat, d3_time_1) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapTextInsideDonut = exports.rotateXAxisLabels = exports.convertToLocaleString = exports.getAccessibleDataObject = exports.pointTypes = exports.CustomPoints = exports.Points = exports.getTypeOfAxis = exports.getMinMaxOfYAxis = exports.findVerticalNumericMinMaxOfY = exports.findVSBCNumericMinMaxOfY = exports.findNumericMinMaxOfY = exports.getDomainNRangeValues = exports.domainRageOfVerticalNumeric = exports.domainRangeOfVSBCNumeric = exports.domainRangeOfXStringAxis = exports.domainRangeOfNumericForAreaChart = exports.domainRangeOfDateForAreaChart = exports.getXAxisType = exports.tooltipOfXAxislabels = exports.createWrapOfXLabels = exports.silceOrAppendToArray = exports.getUnique = exports.calloutData = exports.createStringYAxis = exports.createYAxis = exports.prepareDatapoints = exports.createStringXAxis = exports.createDateXAxis = exports.createNumericXAxis = exports.YAxisType = exports.XAxisTypes = exports.ChartTypes = void 0;
    var ChartTypes;
    (function (ChartTypes) {
        ChartTypes[ChartTypes["AreaChart"] = 0] = "AreaChart";
        ChartTypes[ChartTypes["LineChart"] = 1] = "LineChart";
        ChartTypes[ChartTypes["VerticalBarChart"] = 2] = "VerticalBarChart";
        ChartTypes[ChartTypes["VerticalStackedBarChart"] = 3] = "VerticalStackedBarChart";
        ChartTypes[ChartTypes["GroupedVerticalBarChart"] = 4] = "GroupedVerticalBarChart";
        ChartTypes[ChartTypes["HeatMapChart"] = 5] = "HeatMapChart";
    })(ChartTypes = exports.ChartTypes || (exports.ChartTypes = {}));
    var XAxisTypes;
    (function (XAxisTypes) {
        XAxisTypes[XAxisTypes["NumericAxis"] = 0] = "NumericAxis";
        XAxisTypes[XAxisTypes["DateAxis"] = 1] = "DateAxis";
        XAxisTypes[XAxisTypes["StringAxis"] = 2] = "StringAxis";
    })(XAxisTypes = exports.XAxisTypes || (exports.XAxisTypes = {}));
    var YAxisType;
    (function (YAxisType) {
        YAxisType[YAxisType["NumericAxis"] = 0] = "NumericAxis";
        YAxisType[YAxisType["DateAxis"] = 1] = "DateAxis";
        YAxisType[YAxisType["StringAxis"] = 2] = "StringAxis";
    })(YAxisType = exports.YAxisType || (exports.YAxisType = {}));
    /**
     * Create Numeric X axis
     * @export
     * @param {IXAxisParams} xAxisParams
     */
    function createNumericXAxis(xAxisParams, culture) {
        var domainNRangeValues = xAxisParams.domainNRangeValues, _a = xAxisParams.showRoundOffXTickValues, showRoundOffXTickValues = _a === void 0 ? false : _a, _b = xAxisParams.xAxistickSize, xAxistickSize = _b === void 0 ? 6 : _b, _c = xAxisParams.tickPadding, tickPadding = _c === void 0 ? 10 : _c, _d = xAxisParams.xAxisCount, xAxisCount = _d === void 0 ? 6 : _d, xAxisElement = xAxisParams.xAxisElement;
        var xAxisScale = d3_scale_1.scaleLinear()
            .domain([domainNRangeValues.dStartValue, domainNRangeValues.dEndValue])
            .range([domainNRangeValues.rStartValue, domainNRangeValues.rEndValue]);
        showRoundOffXTickValues && xAxisScale.nice();
        var xAxis = d3_axis_1.axisBottom(xAxisScale)
            .tickSize(xAxistickSize)
            .tickPadding(tickPadding)
            .ticks(xAxisCount)
            .tickSizeOuter(0)
            .tickFormat(function (domainValue, index) {
            var xAxisValue = typeof domainValue === 'number' ? domainValue : domainValue.valueOf();
            return exports.convertToLocaleString(xAxisValue, culture);
        });
        if (xAxisElement) {
            d3_selection_1.select(xAxisElement).call(xAxis).selectAll('text').attr('aria-hidden', 'true');
        }
        return xAxisScale;
    }
    exports.createNumericXAxis = createNumericXAxis;
    function multiFormat(date, locale) {
        var formatMillisecond = locale.format('.%L');
        var formatSecond = locale.format(':%S');
        var formatMinute = locale.format('%I:%M');
        var formatHour = locale.format('%I %p');
        var formatDay = locale.format('%a %d');
        var formatWeek = locale.format('%b %d');
        var formatMonth = locale.format('%B');
        var formatYear = locale.format('%Y');
        return (d3_time_1.timeSecond(date) < date
            ? formatMillisecond
            : d3_time_1.timeMinute(date) < date
                ? formatSecond
                : d3_time_1.timeHour(date) < date
                    ? formatMinute
                    : d3_time_1.timeDay(date) < date
                        ? formatHour
                        : d3_time_1.timeMonth(date) < date
                            ? d3_time_1.timeWeek(date) < date
                                ? formatDay
                                : formatWeek
                            : d3_time_1.timeYear(date) < date
                                ? formatMonth
                                : formatYear)(date);
    }
    /**
     * Creating Date x axis of the Chart
     * @export
     * @param {IXAxisParams} xAxisParams
     * @param {ITickParams} tickParams
     */
    function createDateXAxis(xAxisParams, tickParams, culture, options, timeFormatLocale, customDateTimeFormatter) {
        var domainNRangeValues = xAxisParams.domainNRangeValues, xAxisElement = xAxisParams.xAxisElement, _a = xAxisParams.tickPadding, tickPadding = _a === void 0 ? 6 : _a, _b = xAxisParams.xAxistickSize, xAxistickSize = _b === void 0 ? 6 : _b, _c = xAxisParams.xAxisCount, xAxisCount = _c === void 0 ? 6 : _c;
        var xAxisScale = d3_scale_1.scaleTime()
            .domain([domainNRangeValues.dStartValue, domainNRangeValues.dEndValue])
            .range([domainNRangeValues.rStartValue, domainNRangeValues.rEndValue]);
        var xAxis = d3_axis_1.axisBottom(xAxisScale).tickSize(xAxistickSize).tickPadding(tickPadding).ticks(xAxisCount);
        if (customDateTimeFormatter) {
            xAxis.tickFormat(function (domainValue, _index) {
                return customDateTimeFormatter(domainValue);
            });
        }
        else if (culture && options) {
            xAxis.tickFormat(function (domainValue, _index) {
                return domainValue.toLocaleString(culture, options);
            });
        }
        else if (timeFormatLocale) {
            var locale_1 = d3TimeFormat.timeFormatLocale(timeFormatLocale);
            xAxis.tickFormat(function (domainValue, _index) {
                return multiFormat(domainValue, locale_1);
            });
        }
        tickParams.tickValues ? xAxis.tickValues(tickParams.tickValues) : '';
        if (culture === undefined) {
            tickParams.tickFormat ? xAxis.tickFormat(d3TimeFormat.timeFormat(tickParams.tickFormat)) : '';
        }
        if (xAxisElement) {
            d3_selection_1.select(xAxisElement).call(xAxis).selectAll('text').attr('aria-hidden', 'true');
        }
        return xAxisScale;
    }
    exports.createDateXAxis = createDateXAxis;
    /**
     * Create String X axis
     * Currently using for only Vetical stacked bar chart and grouped vertical bar chart
     * @export
     * @param {IXAxisParams} xAxisParams
     * @param {ITickParams} tickParams
     * @param {string[]} dataset
     * @returns
     */
    function createStringXAxis(xAxisParams, tickParams, dataset, culture) {
        var domainNRangeValues = xAxisParams.domainNRangeValues, _a = xAxisParams.xAxisCount, xAxisCount = _a === void 0 ? 6 : _a, _b = xAxisParams.xAxistickSize, xAxistickSize = _b === void 0 ? 6 : _b, _c = xAxisParams.tickPadding, tickPadding = _c === void 0 ? 10 : _c, _d = xAxisParams.xAxisPadding, xAxisPadding = _d === void 0 ? 0.1 : _d;
        var xAxisScale = d3_scale_1.scaleBand()
            .domain(dataset)
            .range([domainNRangeValues.rStartValue, domainNRangeValues.rEndValue])
            .padding(xAxisPadding);
        var xAxis = d3_axis_1.axisBottom(xAxisScale)
            .tickSize(xAxistickSize)
            .tickPadding(tickPadding)
            .ticks(xAxisCount)
            .tickFormat(function (x, index) {
            return exports.convertToLocaleString(dataset[index], culture);
        });
        if (xAxisParams.xAxisElement) {
            d3_selection_1.select(xAxisParams.xAxisElement).call(xAxis).selectAll('text').attr('aria-hidden', 'true');
        }
        return xAxisScale;
    }
    exports.createStringXAxis = createStringXAxis;
    /**
     * This method used for creating data points for the y axis.
     * @export
     * @param {number} maxVal
     * @param {number} minVal
     * @param {number} splitInto
     * @returns {number[]}
     */
    function prepareDatapoints(maxVal, minVal, splitInto) {
        var val = Math.ceil((maxVal - minVal) / splitInto);
        var dataPointsArray = [minVal, minVal + val];
        while (dataPointsArray[dataPointsArray.length - 1] < maxVal) {
            dataPointsArray.push(dataPointsArray[dataPointsArray.length - 1] + val);
        }
        return dataPointsArray;
    }
    exports.prepareDatapoints = prepareDatapoints;
    /**
     * Creating Numeric Y axis of the chart
     * @export
     * @param {IYAxisParams} yAxisParams
     * @param {boolean} isRtl
     */
    function createYAxis(yAxisParams, isRtl, axisData) {
        var _a = yAxisParams.yMinMaxValues, yMinMaxValues = _a === void 0 ? { startValue: 0, endValue: 0 } : _a, _b = yAxisParams.yAxisElement, yAxisElement = _b === void 0 ? null : _b, _c = yAxisParams.yMaxValue, yMaxValue = _c === void 0 ? 0 : _c, _d = yAxisParams.yMinValue, yMinValue = _d === void 0 ? 0 : _d, containerHeight = yAxisParams.containerHeight, containerWidth = yAxisParams.containerWidth, margins = yAxisParams.margins, _e = yAxisParams.tickPadding, tickPadding = _e === void 0 ? 12 : _e, _f = yAxisParams.maxOfYVal, maxOfYVal = _f === void 0 ? 0 : _f, yAxisTickFormat = yAxisParams.yAxisTickFormat, _g = yAxisParams.yAxisTickCount, yAxisTickCount = _g === void 0 ? 4 : _g, eventAnnotationProps = yAxisParams.eventAnnotationProps, eventLabelHeight = yAxisParams.eventLabelHeight;
        // maxOfYVal coming from only area chart and Grouped vertical bar chart(Calculation done at base file)
        var tempVal = maxOfYVal || yMinMaxValues.endValue;
        var finalYmax = tempVal > yMaxValue ? tempVal : yMaxValue;
        var finalYmin = yMinMaxValues.startValue < yMinValue ? 0 : yMinValue;
        var domainValues = prepareDatapoints(finalYmax, finalYmin, yAxisTickCount);
        var yAxisScale = d3_scale_1.scaleLinear()
            .domain([finalYmin, domainValues[domainValues.length - 1]])
            .range([containerHeight - margins.bottom, margins.top + (eventAnnotationProps ? eventLabelHeight : 0)]);
        var axis = isRtl ? d3_axis_1.axisRight(yAxisScale) : d3_axis_1.axisLeft(yAxisScale);
        var yAxis = axis
            .tickPadding(tickPadding)
            .tickValues(domainValues)
            .tickSizeInner(-(containerWidth - margins.left - margins.right));
        yAxisTickFormat ? yAxis.tickFormat(yAxisTickFormat) : yAxis.tickFormat(d3_format_1.format('.2~s'));
        yAxisElement ? d3_selection_1.select(yAxisElement).call(yAxis).selectAll('text').attr('aria-hidden', 'true') : '';
        axisData.yAxisDomainValues = domainValues;
        return yAxisScale;
    }
    exports.createYAxis = createYAxis;
    /**
     * Creating String Y axis of the chart
     * @param yAxisParams
     * @param dataPoints
     * @param isRtl
     */
    var createStringYAxis = function (yAxisParams, dataPoints, isRtl) {
        var containerHeight = yAxisParams.containerHeight, _a = yAxisParams.tickPadding, tickPadding = _a === void 0 ? 12 : _a, margins = yAxisParams.margins, yAxisTickFormat = yAxisParams.yAxisTickFormat, yAxisElement = yAxisParams.yAxisElement, _b = yAxisParams.yAxisPadding, yAxisPadding = _b === void 0 ? 0 : _b;
        var yAxisScale = d3_scale_1.scaleBand()
            .domain(dataPoints)
            .range([containerHeight - margins.bottom, margins.top])
            .padding(yAxisPadding);
        var axis = isRtl ? d3_axis_1.axisRight(yAxisScale) : d3_axis_1.axisLeft(yAxisScale);
        var yAxis = axis.tickPadding(tickPadding).tickValues(dataPoints).tickSize(0);
        if (yAxisTickFormat) {
            yAxis.tickFormat(yAxisTickFormat);
        }
        yAxisElement ? d3_selection_1.select(yAxisElement).call(yAxis).selectAll('text') : '';
        return yAxisScale;
    };
    exports.createStringYAxis = createStringYAxis;
    function calloutData(values) {
        var combinedResult = [];
        values.forEach(function (element) {
            var elements = element.data
                .filter(function (ele) { return !ele.hideCallout; })
                .map(function (ele) {
                return tslib_1.__assign(tslib_1.__assign({ legend: element.legend }, ele), { color: element.color, index: element.index });
            });
            combinedResult = combinedResult.concat(elements);
        });
        var result = [];
        combinedResult.forEach(function (e1, index) {
            e1.x = e1.x instanceof Date ? e1.x.getTime() : e1.x;
            var filteredValues = [
                {
                    legend: e1.legend,
                    y: e1.y,
                    color: e1.color,
                    yAxisCalloutData: e1.yAxisCalloutData,
                    callOutAccessibilityData: e1.callOutAccessibilityData,
                    index: e1.index,
                },
            ];
            combinedResult.slice(index + 1).forEach(function (e2) {
                e2.x = e2.x instanceof Date ? e2.x.getTime() : e2.x;
                if (e1.x === e2.x) {
                    filteredValues.push({
                        legend: e2.legend,
                        y: e2.y,
                        color: e2.color,
                        yAxisCalloutData: e2.yAxisCalloutData,
                        callOutAccessibilityData: e2.callOutAccessibilityData,
                        index: e2.index,
                    });
                }
            });
            result.push({ x: e1.x, values: filteredValues });
        });
        return getUnique(result, 'x');
    }
    exports.calloutData = calloutData;
    function getUnique(arr, comp) {
        var unique = arr
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            .map(function (e) { return e[comp]; })
            // store the keys of the unique objects
            .map(function (e, i, final) { return final.indexOf(e) === i && i; })
            // eliminate the dead keys & store unique objects
            .filter(function (e) { return arr[e]; })
            .map(function (e) { return arr[e]; });
        return unique;
    }
    exports.getUnique = getUnique;
    /**
     * This function takes two paramerter
     * 1. an array of strings
     * 2. a string value
     * if the value is not present in the given array then it will return the new
     * array by appending the value to the present arrray.
     *
     * if the value is already present in  the given array then it will return the new
     * array by deleteing the value from the the array
     * @param array
     * @param value
     */
    function silceOrAppendToArray(array, value) {
        var pos = array.indexOf(value);
        if (pos === -1) {
            return tslib_1.__spreadArray(tslib_1.__spreadArray([], array), [value]);
        }
        else {
            return array.slice(0, pos).concat(array.slice(pos + 1));
        }
    }
    exports.silceOrAppendToArray = silceOrAppendToArray;
    /**
     * This method used for wrapping of x axis labels (tick values).
     * It breaks down given text value by space separated and calculates the total height needed to display all the words.
     * That value = removal value. This value needs to be remove from total svg height, svg will shrink and
     * total text will be displayed.
     * @export
     * @param {IWrapLabelProps} wrapLabelProps
     * @returns
     */
    function createWrapOfXLabels(wrapLabelProps) {
        var node = wrapLabelProps.node, xAxis = wrapLabelProps.xAxis, noOfCharsToTruncate = wrapLabelProps.noOfCharsToTruncate, showXAxisLablesTooltip = wrapLabelProps.showXAxisLablesTooltip;
        if (node === null) {
            return;
        }
        var axisNode = d3_selection_1.select(node).call(xAxis);
        var removeVal = 0;
        var width = 10;
        var arr = [];
        axisNode.selectAll('.tick text').each(function () {
            var text = d3_selection_1.select(this);
            var totalWord = text.text();
            var truncatedWord = text.text().slice(0, noOfCharsToTruncate) + "...";
            var totalWordLength = text.text().length;
            var words = text.text().split(/\s+/).reverse();
            arr.push(words.length);
            var word = '';
            var line = [];
            var lineNumber = 0;
            var lineHeight = 1.1; // ems
            var y = text.attr('y');
            var dy = parseFloat(text.attr('dy'));
            var tspan = text
                .text(null)
                .append('tspan')
                .attr('x', 0)
                .attr('y', y)
                .attr('id', 'BaseSpan')
                .attr('dy', dy + 'em')
                .attr('data-', totalWord);
            if (showXAxisLablesTooltip && totalWordLength > noOfCharsToTruncate) {
                tspan = text
                    .append('tspan')
                    .attr('id', 'showDots')
                    .attr('x', 0)
                    .attr('y', y)
                    .attr('dy', ++lineNumber * lineHeight + dy + 'em')
                    .text(truncatedWord);
            }
            else if (showXAxisLablesTooltip && totalWordLength <= noOfCharsToTruncate) {
                tspan = text
                    .append('tspan')
                    .attr('id', 'LessLength')
                    .attr('x', 0)
                    .attr('y', y)
                    .attr('dy', ++lineNumber * lineHeight + dy + 'em')
                    .text(totalWord);
            }
            else {
                while ((word = words.pop())) {
                    line.push(word);
                    tspan.text(line.join(' '));
                    if (tspan.node().getComputedTextLength() > width && line.length > 1) {
                        line.pop();
                        tspan.text(line.join(' '));
                        line = [word];
                        tspan = text
                            .append('tspan')
                            .attr('id', 'WordBreakId')
                            .attr('x', 0)
                            .attr('y', y)
                            .attr('dy', ++lineNumber * lineHeight + dy + 'em')
                            .text(word);
                    }
                }
                var maxDigit = Math.max.apply(Math, arr);
                var maxHeight_1 = 12; // intial value to render corretly first time
                axisNode.selectAll('text').each(function () {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    var outerHTMLElement = document.getElementById('WordBreakId');
                    var BoxCordinates = outerHTMLElement && outerHTMLElement.getBoundingClientRect();
                    var boxHeight = BoxCordinates && BoxCordinates.height;
                    if (boxHeight > maxHeight_1) {
                        maxHeight_1 = boxHeight;
                    }
                });
                // If we take directly maxDigit * maxheight, then it will show more height between x axis tick values and bottom.
                // To avoid this, reducing maxDigit value by removing some digit based on legth of word.
                var removeDigit = 4;
                if (maxDigit <= 2) {
                    removeDigit = 1;
                }
                else if (maxDigit > 2 && maxDigit <= 6) {
                    removeDigit = 2;
                }
                else if (maxDigit > 6 && maxDigit <= 9) {
                    removeDigit = 3;
                }
                removeVal = (maxDigit - removeDigit) * maxHeight_1;
            }
        });
        return removeVal > 0 ? removeVal : 0;
    }
    exports.createWrapOfXLabels = createWrapOfXLabels;
    /**
     * This method displays a tooltip to the x axis lables(tick values)
     * when prop 'showXAxisLablesTooltip' enables to the respected chart.
     * On hover of the truncated word(at x axis labels tick), a tooltip will be appeared.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function tooltipOfXAxislabels(xAxistooltipProps) {
        var tooltipCls = xAxistooltipProps.tooltipCls, xAxis = xAxistooltipProps.xAxis, id = xAxistooltipProps.id;
        if (xAxis === null) {
            return null;
        }
        var div = d3_selection_1.select('body').append('div').attr('id', id).attr('class', tooltipCls).style('opacity', 0);
        var aa = xAxis.selectAll('#BaseSpan')._groups[0];
        var baseSpanLength = aa && Object.keys(aa).length;
        var originalDataArray = [];
        for (var i = 0; i < baseSpanLength; i++) {
            var originalData = aa[i].dataset && Object.values(aa[i].dataset)[0];
            originalDataArray.push(originalData);
        }
        var tickObject = xAxis.selectAll('.tick')._groups[0];
        var tickObjectLength = tickObject && Object.keys(tickObject).length;
        var _loop_1 = function (i) {
            var d1 = tickObject[i];
            d3_selection_1.select(d1)
                .on('mouseover', function (d) {
                div.style('opacity', 0.9);
                div
                    .html(originalDataArray[i])
                    .style('left', d3_selection_1.event.pageX + 'px')
                    .style('top', d3_selection_1.event.pageY - 28 + 'px');
            })
                .on('mouseout', function (d) {
                div.style('opacity', 0);
            });
        };
        for (var i = 0; i < tickObjectLength; i++) {
            _loop_1(i);
        }
    }
    exports.tooltipOfXAxislabels = tooltipOfXAxislabels;
    /**
     * Find the axis type of line chart and area chart from given data
     * @param points
     */
    function getXAxisType(points) {
        var isXAxisDateType = false;
        if (points && points.length > 0) {
            points.forEach(function (chartData) {
                if (chartData.data.length > 0) {
                    isXAxisDateType = chartData.data[0].x instanceof Date;
                    return;
                }
            });
        }
        return isXAxisDateType;
    }
    exports.getXAxisType = getXAxisType;
    /**
     * Calculates Domain and range values for Date X axis.
     * This method calculates Area chart and line chart.
     * @export
     * @param {ILineChartPoints[]} points
     * @param {IMargins} margins
     * @param {number} width
     * @param {boolean} isRTL
     * @param {Date[] | number[]} tickValues
     * @returns {IDomainNRange}
     */
    function domainRangeOfDateForAreaChart(points, margins, width, isRTL, tickValues) {
        if (tickValues === void 0) { tickValues = []; }
        var sDate = d3_array_1.min(points, function (point) {
            return d3_array_1.min(point.data, function (item) {
                return item.x;
            });
        });
        var lDate = d3_array_1.max(points, function (point) {
            return d3_array_1.max(point.data, function (item) {
                return item.x;
            });
        });
        // Need to draw graph with given small and large date (Which Involves customization of date axis tick values)
        // That may be Either from given graph data or from prop 'tickValues' date values.
        // So, Finding smallest and largest dates
        var smallestDate = d3_array_1.min(tslib_1.__spreadArray(tslib_1.__spreadArray([], tickValues), [sDate]));
        var largestDate = d3_array_1.max(tslib_1.__spreadArray(tslib_1.__spreadArray([], tickValues), [lDate]));
        var rStartValue = margins.left;
        var rEndValue = width - margins.right;
        return isRTL
            ? { dStartValue: largestDate, dEndValue: smallestDate, rStartValue: rStartValue, rEndValue: rEndValue }
            : { dStartValue: smallestDate, dEndValue: largestDate, rStartValue: rStartValue, rEndValue: rEndValue };
    }
    exports.domainRangeOfDateForAreaChart = domainRangeOfDateForAreaChart;
    /**
     * Calculates Domain and range values for Numeric X axis.
     * This method calculates Area cart and line chart.
     * @export
     * @param {ILineChartPoints[]} points
     * @param {IMargins} margins
     * @param {number} width
     * @param {boolean} isRTL
     * @returns {IDomainNRange}
     */
    function domainRangeOfNumericForAreaChart(points, margins, width, isRTL) {
        var xMin = d3_array_1.min(points, function (point) {
            return d3_array_1.min(point.data, function (item) { return item.x; });
        });
        var xMax = d3_array_1.max(points, function (point) {
            return d3_array_1.max(point.data, function (item) {
                return item.x;
            });
        });
        var rStartValue = margins.left;
        var rEndValue = width - margins.right;
        return isRTL
            ? { dStartValue: xMax, dEndValue: xMin, rStartValue: rStartValue, rEndValue: rEndValue }
            : { dStartValue: xMin, dEndValue: xMax, rStartValue: rStartValue, rEndValue: rEndValue };
    }
    exports.domainRangeOfNumericForAreaChart = domainRangeOfNumericForAreaChart;
    /**
     * Calculates Range values of x Axis string axis
     * For String axis, we need to give domain values (Not start and end array values)
     * So sending 0 as domain values. Domain will be handled at creation of string axis
     * For charts stacked bar chart, grouped vertical bar chart, HeatMapChart and Vertical bar chart
     * @export
     * @param {IMargins} margins
     * @param {number} width
     * @param {boolean} isRTL
     * @returns {IDomainNRange}
     */
    function domainRangeOfXStringAxis(margins, width, isRTL) {
        var rMin = margins.left;
        var rMax = width - margins.right;
        return isRTL
            ? { dStartValue: 0, dEndValue: 0, rStartValue: rMax, rEndValue: rMin }
            : { dStartValue: 0, dEndValue: 0, rStartValue: rMin, rEndValue: rMax };
    }
    exports.domainRangeOfXStringAxis = domainRangeOfXStringAxis;
    /**
     * Calculate domain and range values to the Vertical stacked bar chart - For Numeric axis
     * @export
     * @param {IDataPoint[]} points
     * @param {IMargins} margins
     * @param {number} width
     * @param {boolean} isRTL
     * @param {number} barWidth
     * @returns {IDomainNRange}
     */
    function domainRangeOfVSBCNumeric(points, margins, width, isRTL, barWidth) {
        var xMin = d3_array_1.min(points, function (point) { return point.x; });
        var xMax = d3_array_1.max(points, function (point) { return point.x; });
        // barWidth / 2 - for to get tick middle of the bar
        var rMax = margins.left + barWidth / 2;
        var rMin = width - margins.right - barWidth / 2;
        return isRTL
            ? { dStartValue: xMax, dEndValue: xMin, rStartValue: rMax, rEndValue: rMin }
            : { dStartValue: xMin, dEndValue: xMax, rStartValue: rMax, rEndValue: rMin };
    }
    exports.domainRangeOfVSBCNumeric = domainRangeOfVSBCNumeric;
    /**
     * Calculate domain and range values to the Vertical bar chart - For Numeric axis
     * @export
     * @param {IDataPoint[]} points
     * @param {IMargins} margins
     * @param {number} containerWidth
     * @param {boolean} isRTL
     * @param {number} barWidth
     * @returns {IDomainNRange}
     */
    function domainRageOfVerticalNumeric(points, margins, containerWidth, isRTL, barWidth) {
        var xMax = d3_array_1.max(points, function (point) { return point.x; });
        var xMin = d3_array_1.min(points, function (point) { return point.x; });
        var rMin = margins.left + barWidth;
        var rMax = containerWidth - margins.right - barWidth;
        return isRTL
            ? { dStartValue: xMax, dEndValue: xMin, rStartValue: rMin, rEndValue: rMax }
            : { dStartValue: xMin, dEndValue: xMax, rStartValue: rMin, rEndValue: rMax };
    }
    exports.domainRageOfVerticalNumeric = domainRageOfVerticalNumeric;
    /**
     * For creating X axis, need to calculate x axis domain and range values from given points.
     * This may vary based on chart type and type of x axis
     * So, this method will define which method need to call based on chart type and axis type.
     * @export
     * @param {*} points
     * @param {IMargins} margins
     * @param {number} width
     * @param {ChartTypes} chartType
     * @param {boolean} isRTL
     * @param {XAxisTypes} xAxisType
     * @param {number} [barWidth]
     * @returns {IDomainNRange}
     */
    function getDomainNRangeValues(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    points, margins, width, chartType, isRTL, xAxisType, barWidth, tickValues) {
        var domainNRangeValue;
        if (xAxisType === XAxisTypes.NumericAxis) {
            switch (chartType) {
                case ChartTypes.AreaChart:
                case ChartTypes.LineChart:
                    domainNRangeValue = domainRangeOfNumericForAreaChart(points, margins, width, isRTL);
                    break;
                case ChartTypes.VerticalStackedBarChart:
                    domainNRangeValue = domainRangeOfVSBCNumeric(points, margins, width, isRTL, barWidth);
                    break;
                case ChartTypes.VerticalBarChart:
                    domainNRangeValue = domainRageOfVerticalNumeric(points, margins, width, isRTL, barWidth);
                    break;
                default:
                    domainNRangeValue = { dStartValue: 0, dEndValue: 0, rStartValue: 0, rEndValue: 0 };
            }
        }
        else if (xAxisType === XAxisTypes.DateAxis) {
            switch (chartType) {
                case ChartTypes.AreaChart:
                case ChartTypes.LineChart:
                    domainNRangeValue = domainRangeOfDateForAreaChart(points, margins, width, isRTL, tickValues);
                    break;
                default:
                    domainNRangeValue = { dStartValue: 0, dEndValue: 0, rStartValue: 0, rEndValue: 0 };
            }
        }
        else {
            // String Axis type
            switch (chartType) {
                case ChartTypes.VerticalStackedBarChart:
                case ChartTypes.GroupedVerticalBarChart:
                case ChartTypes.VerticalBarChart:
                case ChartTypes.HeatMapChart:
                    domainNRangeValue = domainRangeOfXStringAxis(margins, width, isRTL);
                    break;
                default:
                    domainNRangeValue = { dStartValue: 0, dEndValue: 0, rStartValue: 0, rEndValue: 0 };
            }
        }
        return domainNRangeValue;
    }
    exports.getDomainNRangeValues = getDomainNRangeValues;
    /**
     * Calculating start and ending values of the Area chart and LineChart
     * @export
     * @param {ILineChartPoints[]} points
     * @returns {{ startValue: number; endValue: number }}
     */
    function findNumericMinMaxOfY(points) {
        var yMax = d3_array_1.max(points, function (point) {
            return d3_array_1.max(point.data, function (item) { return item.y; });
        });
        var yMin = d3_array_1.min(points, function (point) {
            return d3_array_1.min(point.data, function (item) { return item.y; });
        });
        return {
            startValue: yMin,
            endValue: yMax,
        };
    }
    exports.findNumericMinMaxOfY = findNumericMinMaxOfY;
    /**
     * Find the minimum and maximum values of the vertical stacked bar chart y axis data point. Used for create y axis.
     * @export
     * @param {IDataPoint[]} dataset
     * @returns {{ startValue: number; endValue: number }}
     */
    function findVSBCNumericMinMaxOfY(dataset) {
        var yMax = d3_array_1.max(dataset, function (point) { return point.y; });
        var yMin = d3_array_1.min(dataset, function (point) { return point.y; });
        return { startValue: yMin, endValue: yMax };
    }
    exports.findVSBCNumericMinMaxOfY = findVSBCNumericMinMaxOfY;
    /**
     * Fins the min and max values of the vertical bar chart y axis data point.
     * @export
     * @param {IVerticalBarChartDataPoint[]} points
     * @returns {{ startValue: number; endValue: number }}
     */
    function findVerticalNumericMinMaxOfY(points) {
        var yMax = d3_array_1.max(points, function (point) { return point.y; });
        var yMin = d3_array_1.min(points, function (point) { return point.y; });
        return { startValue: yMin, endValue: yMax };
    }
    exports.findVerticalNumericMinMaxOfY = findVerticalNumericMinMaxOfY;
    /**
     * For creating Y axis, need to calculate y axis domain values from given points. This may vary based on chart type.
     * So, this method will define which method need to call based on chart type to find out min and max values(For Domain).
     * For grouped vertical bar chart, Calculating yMax value in the base file and sending as MaxOfYVal to cartesian.
     * @export
     * @param {*} points
     * @param {ChartTypes} chartType
     * @returns {{ startValue: number; endValue: number }}
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function getMinMaxOfYAxis(points, chartType) {
        var minMaxValues;
        switch (chartType) {
            case ChartTypes.AreaChart:
            case ChartTypes.LineChart:
                minMaxValues = findNumericMinMaxOfY(points);
                break;
            case ChartTypes.VerticalStackedBarChart:
                minMaxValues = findVSBCNumericMinMaxOfY(points);
                break;
            case ChartTypes.VerticalBarChart:
                minMaxValues = findVerticalNumericMinMaxOfY(points);
                break;
            default:
                minMaxValues = { startValue: 0, endValue: 0 };
        }
        return minMaxValues;
    }
    exports.getMinMaxOfYAxis = getMinMaxOfYAxis;
    /**
     * @param p string or number or Date
     *
     * This function takes the single data point of the x-aixs
     * and decides what is the x-axis
     */
    var getTypeOfAxis = function (p, isXAsix) {
        if (isXAsix) {
            switch (typeof p) {
                case 'string':
                    return XAxisTypes.StringAxis;
                case 'number':
                    return XAxisTypes.NumericAxis;
                default:
                    return XAxisTypes.DateAxis;
            }
        }
        else {
            switch (typeof p) {
                case 'string':
                    return YAxisType.StringAxis;
                case 'number':
                    return YAxisType.NumericAxis;
                default:
                    return YAxisType.DateAxis;
            }
        }
    };
    exports.getTypeOfAxis = getTypeOfAxis;
    /**
     * we need to make sure that if we add any property to this, then
     * we need to also add that in  pointTypes below and vise-versa
     */
    var Points;
    (function (Points) {
        Points[Points["circle"] = 0] = "circle";
        Points[Points["square"] = 1] = "square";
        Points[Points["triangle"] = 2] = "triangle";
        Points[Points["diamond"] = 3] = "diamond";
        Points[Points["pyramid"] = 4] = "pyramid";
        Points[Points["hexagon"] = 5] = "hexagon";
        Points[Points["pentagon"] = 6] = "pentagon";
        Points[Points["octagon"] = 7] = "octagon";
    })(Points = exports.Points || (exports.Points = {}));
    var CustomPoints;
    (function (CustomPoints) {
        CustomPoints[CustomPoints["dottedLine"] = 0] = "dottedLine";
    })(CustomPoints = exports.CustomPoints || (exports.CustomPoints = {}));
    /**
     * we need to make sure that if we add any property to this, then
     * we need to also add that in enum Point and vise-versa
     */
    exports.pointTypes = (_a = {},
        _a[Points.circle] = {
            widthRatio: 1,
        },
        _a[Points.square] = {
            widthRatio: 1,
        },
        _a[Points.triangle] = {
            widthRatio: 1,
        },
        _a[Points.diamond] = {
            widthRatio: 1,
        },
        _a[Points.pyramid] = {
            widthRatio: 1,
        },
        _a[Points.hexagon] = {
            widthRatio: 2,
        },
        _a[Points.pentagon] = {
            widthRatio: 1.168,
        },
        _a[Points.octagon] = {
            widthRatio: 2.414,
        },
        _a);
    /**
     * @param accessibleData accessible data
     * @param role string to define role of tag
     * @param isDataFocusable boolean
     * function returns the accessibility data object
     */
    var getAccessibleDataObject = function (accessibleData, role, isDataFocusable) {
        if (role === void 0) { role = 'text'; }
        if (isDataFocusable === void 0) { isDataFocusable = true; }
        accessibleData = accessibleData !== null && accessibleData !== void 0 ? accessibleData : {};
        return {
            role: role,
            'data-is-focusable': isDataFocusable,
            'aria-label': accessibleData.ariaLabel,
            'aria-labelledby': accessibleData.ariaLabelledBy,
            'aria-describedby': accessibleData.ariaDescribedBy,
        };
    };
    exports.getAccessibleDataObject = getAccessibleDataObject;
    var convertToLocaleString = function (data, culture) {
        if (!data) {
            return data;
        }
        culture = culture || undefined;
        if (typeof data === 'number') {
            return data.toLocaleString(culture);
        }
        if (typeof data === 'string' && !window.isNaN(Number(data))) {
            var num = Number(data);
            return num.toLocaleString(culture);
        }
        return data;
    };
    exports.convertToLocaleString = convertToLocaleString;
    function rotateXAxisLabels(rotateLabelProps) {
        var node = rotateLabelProps.node, xAxis = rotateLabelProps.xAxis;
        if (node === null || xAxis === null) {
            return;
        }
        var maxHeight = 0;
        var xAxisTranslations = [];
        d3_selection_1.select(node)
            .call(xAxis)
            .selectAll('.tick')
            .each(function () {
            var translateValue = this.getAttribute('transform');
            if ((translateValue === null || translateValue === void 0 ? void 0 : translateValue.indexOf('rotate')) === -1) {
                var translatePair = translateValue
                    .substring(translateValue.indexOf('(') + 1, translateValue.indexOf(')'))
                    .split(',');
                if (translatePair.length === 2) {
                    xAxisTranslations.push(translatePair[0]);
                    this.setAttribute('transform', "translate(" + translatePair[0] + ",0)rotate(-45)");
                }
            }
            var BoxCordinates = this.getBoundingClientRect();
            var boxHeight = BoxCordinates && BoxCordinates.height;
            if (boxHeight > maxHeight) {
                maxHeight = boxHeight;
            }
        });
        var idx = 0;
        d3_selection_1.select(node)
            .call(xAxis)
            .selectAll('.tick')
            .each(function () {
            if (xAxisTranslations.length > idx) {
                this.setAttribute('transform', "translate(" + xAxisTranslations[idx] + "," + maxHeight / 2 + ")rotate(-45)"); // Translate y by max height/2
                idx += 1;
            }
        });
        return Math.floor(maxHeight / 1.414); // Compute maxHeight/tanInverse(45) to get the vertical height of labels.
    }
    exports.rotateXAxisLabels = rotateXAxisLabels;
    function wrapTextInsideDonut(selectorClass, maxWidth) {
        var idx = 0;
        d3_selection_1.selectAll("." + selectorClass).each(function () {
            var text = d3_selection_1.select(this);
            var words = text.text().split(/\s+/).reverse();
            var word = '';
            var line = [];
            var lineNumber = 0;
            var lineHeight = 1.1; // ems
            var y = text.attr('y');
            var tspan = text
                .text(null)
                .append('tspan')
                .attr('id', "WordBreakId-" + idx + "-" + lineNumber)
                .attr('x', 0)
                .attr('y', y)
                .attr('dy', lineNumber++ * lineHeight + 'em');
            while ((word = words.pop())) {
                line.push(word);
                tspan.text(line.join(' ') + ' ');
                if (tspan.node().getComputedTextLength() > maxWidth && line.length > 1) {
                    line.pop();
                    tspan.text(line.join(' ') + ' ');
                    line = [word];
                    tspan = text
                        .append('tspan')
                        .attr('id', "WordBreakId-" + idx + "-" + lineNumber)
                        .attr('x', 0)
                        .attr('y', y)
                        .attr('dy', lineNumber++ * lineHeight + 'em')
                        .text(word);
                }
            }
            idx += 1;
        });
    }
    exports.wrapTextInsideDonut = wrapTextInsideDonut;
});
//# sourceMappingURL=utilities.js.map